# 堆和优先队列
## 优先队列
- 普通队列: 先进先出; 后进后出
- 有限队列: 出队顺序和入队顺序无关; 和优先级有关

### 使用实例
- 任务调度: 根据优先级进行任务调度
- 游戏中的自动打怪

### 优先队列
- 普通线性结构
  - 入队: O(1)
  - 出队: O(n)(扫描所有元素, 获取最大优先级的元素)
- 顺序线性结构(维持所有元素的顺序)
  - 入队: O(n)(确认元素插入到线性结构的具体位置)
  - 出队: O(1)(最大或者最小元素都能很快确定)
- 堆
  - 入队: O(logn)
  - 出队：O(logn)

## 堆的基本结构
### 二叉堆
- 二叉堆是一颗完全二叉树
  - 完全二叉树: 把元素顺序排列成树的形状
- 堆中某个节点的值总是不大于其父节点的值(最大堆)
  - parent(i) = i / 2
  - left child (i) = 2 * i;
  - right child (i) = 2 * i + 1
  - 这种算法从1开始计算第一个元素，导致了0索引出的位置始终为null
- 如果采用从0开始计算第一个元素, 则有
  - parent(i) = (i - 1) >> 1;
  - left child (i) = 2 * i + 1
  - right child (1) = 2 * i + 2
- 是一棵平衡二叉树

```
# 完全二叉树的表示方法
          60
        /   \
      22     21
      / \   /  \
    19  17 16  14
   /  \
 11   10

 采用数组表示法为:[60, 18, 21, 19, 17, 16, 14, 11, 10]
```
- 向堆中添加元素和Sift up
  - 因为完全二叉树需要满足: 父节点始终大于或者等于孩子节点
  - 因此对于插入的节点，只需要判断父亲节点进行判断即可
### 从堆中取出最大元素或者最小元素
- 从堆中取出并删除元素，需要对数据进行下沉操作(sift down)
  - 删除第一个节点
  - 将最后一个节点放到第一个节点位置
  - 删除最后一个节点
  - 然后将第一个节点与左右子树进行比较，如果左右子树都比当前节点大, 则与左右子树中最大的节点记性交换位置, 依次类推

### 时间复杂度
- add 和extractMax的时间复杂度都是O(logn)

## 优先队列的经典问题
- 在 1000000 个元素中选出前100名
  - 在N个元素中选出前M个元素
    - 排序? NlogN(归并排序)
    - 使用优先队列? NlogM
  - 使用优先队列，维护当前看到的前M个元素
    - 需要使用最小堆

### leetcode上的题
```
给定一个非空数组，返回其中出现频率前K高的元素

给定数组[1,1,1,2,2,3] 和 k =2返回[1,2]
```

## 实现d-ary heap, 多叉堆
## 索引堆
