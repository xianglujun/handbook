# 变量

`var`声明创建一个具体类型的变量，并为变量设置一个具体的名字，以及初始值。声明变量的通用形式为：

```go
var name type = expression
```



## 初始值

类型和表达式部分可以省略一个，但是不能全部省略:

- 如果省略类型，它的类型将由初始化表示决定
- 如果表达式省略，其初始值对应于类型的零值

### 类型初始化值

| 类型                                   | 初始化值                     |
| -------------------------------------- | ---------------------------- |
| 数字                                   | 0                            |
| 布尔类型                               | false                        |
| 字符串                                 | `""`                         |
| 接口                                   | `nil`                        |
| 引用类型(slice, 指针, map, 通道, 函数) | `nil`                        |
| 数组、结构体                           | 零值是其所有元素或成员的零值 |



## 变量定义方式

1. 可以声明变量表达式列表，并对其进行初始化

```go
var i, j, k int
var b, f, s = true, 2.3, "four"
```

2. 可以通过函数的方式为变量表达式赋值

```go
var f, err = os.Open(name)
```



### 变量初始化时机

- 包级别的初始化在main开始前进行
- 局部变量初始化和声明一样在函数执行期间进行



## 短变量声明

`短变量声明`可选形式可以用来声明和初始化局部变量, 采用`name := expression`的形式, name的类型由expression的类型决定。

通过这种方式声明变量，短小、灵活、因此在局部变量的声明和初始化中主要使用短声明。

而对于`var`声明来说，主要用于初始化表达式类型不一致的局部变量或者变量的声明和赋值不统一的情况。

> 一个被忽略的地方是：短变量声明不需要声明所有在左边的变量。如果在同一个块中声明，短变量的声明行为等同于赋值.
>
> ```go
> in, err := os.Open(infile)
> out, err := os.Create(outfile)
> ```
>
> 

> 同时，`:=`的语法，要求在对变量的什么时候，必须要有一个新变量, 否则，代码编译无法通过
>
> ```go
> f, err := os.Open(infile)
> f, err := os.Create(outfile)
> ```
>
> 



## new函数

在go中同时提供了另外一种创建变量的方式`new函数`. 可以通过表示`new(type)`创建一个未命名的type类行变量，初始化为type类型的零值，并返回其地址(地址类型为*type)

```go
package main

import "gops.io/src/gops.io/util"

// 该方法主要实现通过new函数创建变量，并为其赋值实现
func main() {

	p := new(int)
	util.Printfln("当前类型为: %T", p)

	// 为变量赋值
	*p = 2
	util.Printfln("赋值后的结果为: %d", *p)

	// 比较两个创建的地址是否相等
	q := new(int)
	util.Printfln("两者是否相等: %t", (q == p))

	// new函数中的特殊情况
	// 如果通过new的方式创建struct{}或者[0]int, 他们具有相同的地址
	s := new(struct{})
	r := new(struct{})
	util.Printfln("两个struct{}是否相等: %t", (r == s))

	// 比较两个不一样的[0]int
	ar := new([0]int)
	ar1 := new([0]int)

	util.Printfln("两个[0]int是否相等: %t", (ar == ar1))

}

```

> 当前版本为v1.16，因此以上两个不携带任何信息且是零值的new创建变量，两则并不相等。但是低版本的go中，可能会返回结果为true.



## 变量生命周期

`生命周期`指在程序执行过程中变量存在的时间段。

- 包级别变量的生命周期是整个程序的执行时间。
- 局部变量有一个动态的生命周期
  - 每次执行声明语句时，创建一个新的实例，变量一直生存到它变得不可访问，这时它占用的存储空间被回收
  - 函数的参数和返回值也是局部变量，他们在其闭包哈桑农户被调用的时候创建。
