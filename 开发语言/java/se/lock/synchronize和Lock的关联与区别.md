## synchronized和Lock的区别
这个问题在很多面试的过程中, 都已经被问及了太多次了,  因此这里做一个详细的笔记, 用来从各个的方面来区分两者的区别.

`Lock`是对`synchronized`的JDK层面的实现，其中提供了`synchronized`不具备的特性. 并且所有的加锁的方式都是显式的。

### 两者的对比
|可比项|synchronized|Lock|
|:-----------|:-----------|:---------|
|JVM实现|是   |否   |
|是否可重入   |是   |是   |
|是否锁等待超时   |否   |是   |
|是否可中断   |否   |是   |
|是否自动释放锁   |是   |否   |
|是否是重量级锁   |是   |否   |

> NOTE: 对于`Lock`而言, 所有的加锁和释放锁的操作都是通过代码显式的方式的进行，然而当锁定的代码中抛出异常时，如果不做释放锁的处理，就会导致锁无法被释放(除非设定锁超时)。因此我们在使用`Lock`的方式进行加锁时，需要使用`finally`的方式进行释放锁, 已达到锁定代码在被释放时，不至于导致死锁的问题。

### 轮询锁和定时锁
轮询锁和定时锁在`Lock`中都是通过`tryLock`来进行获取, 与无条件的锁相比, 具备了更高的容错能力。在内置的锁中, 最大的问题就是导致了死锁, 而发生死锁的最大的原因在于使用了不一致的锁定顺序。然而轮询锁和定时锁则提供了另外的一种选择: 避免死锁的发生。

### 性能的影响因素
在`1.5`版本中, `Lock` 比内置锁有着更高的吞吐量，并且随着请求的上升，吞吐量下降的较为平缓。 而在`1.6`版本中, 两者的情况已经非常接近，内置锁不会因为竞争的激烈而导致性能的急剧下降, 并且两者的可伸缩性基本相当。
