# 慎用则表达式

## 正则表达式的组成部分

- `普通字符`: 字母`[a-zA-Z]`, 数字`[0-9]`, 下划线`[_]`， 标点符号等
- `标准字符`: 能够与`多种普通字符`匹配的简单表达式. 例如`\d`, `\w`, `\s`
- `限定字符`: 用于标示匹配的字符的数量。例如`*, +, ?, {n}`
- `定位字符`: `等宽`， 标记匹配复核某种条件的位置. 例如`$,^`

## 正则表达式引擎

`正则表达式`是一个正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序(这个程序也叫做`状态机`)



### 正则表达式引擎分类

- DFA自动机(Deterministic Final Automaton 确定有限状态自动机)
- NFA自动机(Non deterministic Finite Automaton. 非确定有限状态自动机)

> `NFA`自动机的优势是支持多功能。例如`捕获group`, `环视`,`占有优先量词`等高级功能。这些功能都是基于子表达式独立进行匹配，因此在编程语言里，使用的正则表达式库都是基于NFA实现的。



#### NFA的字符匹配过程

> text="aabcab"
>
> regex="bc"

1. 首先，读取正则表达式`regex`的第一个匹配符和字符串`text`的第一个字符进行比较。即`b对a`, 不匹配；继续换字符串`text`的下一个字符，也是a, 不匹配；继续换字符串`text`下一个，是`b`, 匹配。

![image-20200328232945091](../../img\java\image-20200328232945091.png)

2. 同理，读取正则表达式`regex`第二个匹配符合字符串`text`的第四个字符进行匹配，`c对c`， 匹配；继续读取正则表达式的下一个字符，然而后面已经没有可以匹配的字符了，结束。

![image-20200328233229367](../../img/java/image-20200328233229367.png)

## NFA自动机的回溯

> 用NFA自动机实现的比较复杂的正则表达式，在匹配过程中经常引起回溯问题。大量的回溯会长时间地占用CPU, 从而带来系统性能开销。

> text='abbc'
>
> regex="ab{1,3}c"

1. 首先，读取正则表达式`regex`第一个匹配符`a`和字符串`text`的第一个字符`a`进行比较，匹配

![image-20200328233605151](../../img/java/image-20200328233605151.png)

2. 读取正则表达式`regex`第二个匹配符`b{1,3}`和字符串`text`的第二个b进行比较，匹配。但是，因为`b{1,3}`表示`1-3个b`字符串，NFA自动机又具有贪婪特性，所以此时不会继续读取正则表达式`regex`的下一个匹配符，而是依旧使用`b{1,3}`和字符串`text`的第三个字符b进行比较，结果还是匹配。

![image-20200328233913369](../../img/java/image-20200328233913369.png)

3. 接着继续使用正则表达式`regext``b{1,3}`和字符串`text`第四个字符c进行比较，发现不匹配了，此时会发生`回溯`, 已经读取的字符串`text`的第四个字符串`c`将被吐出去，指针回到第三个字符`b`的位置

![image-20200328234134787](../../img/java/image-20200328234134787.png)

4. 程序读取正则表达式`regex`下一个匹配符`c`, 和字符串中的第四个字符`c`进行比较，结果匹配，结束

![image-20200328234259979](../../img/java/image-20200328234259979.png)

### NFA的三种模式

#### 贪婪模式（Greedy）

顾名思义，就是在数量匹配中，单独使用`+,?,*或者{m,n}`等两次，正则表达式就会尽量多的匹配内容。

> text="abbc"
>
> regex="ab{1,3}c"

就是在贪婪模式下，NFA自动机读取了大量的匹配范围，即匹配3个b字符。匹配发生了一次失败，就引起了`回溯`。 如果匹配结果是`abbbc`, 就会匹配成功

> text="abbbc"
>
> regext="ab{1,3}c"



#### 懒惰模式（Reluctant）

在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。

例如，在以上的正则之后加入一个`?`, 就可以开启懒惰模式

> text="abc"
>
> regext="ab{1,3}?c"

`懒惰模式是无法完全避免回溯的`。例如以下的例子:

> text="abbc"
>
> regex="ab{1,3}?c"

1. 读取正则表达式`regex`第一个匹配符`a`和字符串`text`一个字符`a`，结果为匹配。然后，读取正则表达式`regex`第二个匹配符`b{1,3}`和字符串`text`的第二个字符`b`，匹配。

![image-20200328235418531](../../img/java/image-20200328235418531.png)

2. 由于懒惰模式下，正则表达式会皆可能地减少重复匹配字符，匹配字符串`text`中的下一个匹配符b不会继续与正则表达式`regext`的字符`b{1,3}进行匹配`，从而放弃最大匹配符`b`字符，转而匹配正则表达式中的下一个字符`c`

![image-20200328235622000](../../img/java/image-20200328235622000.png)

3. 此时匹配字符串`text`字符`c`与正则表达式中`regex`中的字符`c`不匹配，这个时候发生一次`回溯`, 这次的回溯与贪婪模式中的回溯刚好相反，懒惰模式的回溯是回溯正则表达式中一个匹配字符，与上一个字符再进行匹配。如果匹配，则将匹配字符串的下一个字符与正则个表达式`regex`的下一个字符再次匹配。

![image-20200328235853959](../../img/java/image-20200328235853959.png)

#### 独占模式(Possessive)

**同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯行为**

在上面的例子中，可以通过在字符后面加入一个`+`, 就可以开启独占模式。

> text="abbc"
>
> regex="ab{1,3}+bc"

同样,`独占模式也不能避免回溯的发生`。例如:

> text="abbc"
>
> regex="ab{1,3}+c"

结果是匹配的，这是因为`与贪婪模式一样，独占模式一样会最大限度地匹配更多内容`



## 正则表达式的优化

1. 少用贪婪模式，多用独占模式

贪婪模式会引起回溯问题，我们可以使用独占模式来避免回溯

2. 减少分支选择

分支选择类型`(x|y|z)`的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，可以采用以下几种方式来优化:

- 需要考虑选择的顺序，将比较常用的选择项放在前面，使他们可以较快地被匹配
- 可以尝试提取功用模式，例如将`(abcd|abef)`替换为`ab(cd|ef)`后者的匹配速度较快，因为NFA自动机会尝试匹配`ab`，如果没有找到，就不会尝试任何选项
- 如果是简单的分支选择类型，我们可以用三次`String.indexOf`代替`(x|y|z)`, 如果测试的话，三次`index`的效率要比`(x|y|z)`高出一些。

3. 减少捕获嵌套

`捕获组`: 是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显示命名的数组中，方便后面引用。一般一个`()`就是一个捕获组，捕获组可以进行嵌套。

`非捕获组`: 是指参与匹配不进行分组编号的`捕获组`，其表达式一般由`?:exp`组成。

