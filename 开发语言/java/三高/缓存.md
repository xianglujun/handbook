# 缓存

## 如何提升缓存的收益

- 减少以下步骤时间:
  
  - 计算k值
  
  - 查询k值
  
  - 得到值，并做转换

- 提高命中率

### 应用场景

- 读多写少用缓存

- 查询原数据时间比较长的场景

## Key

### 生成时间

键key有关的信息，不同功能业务的，key值要不一样，否则会有key被覆盖的风险。

> 要唯一，避免产生key的碰撞。

**单向函数**：hash。给定输入的情况下，很容易计算出结果，而给定结果的情况下，几乎不可能计算出输入值。

### 查询时间

- 与缓存的位置有关。内存，硬盘，本地。

- 数据结构

- 数据长度。

### 总结

- 无碰撞（唯一），通过业务信息进行区分

- 高效生成（不需要，约定好（系统标识 + 功能标识 + 业务标识 + 前后缀）

- 高效比较

## 值

- 序列化值（二进制），对象值
  
  - 存储对象，会存在**数据污染问题**，可能存储的是一个中间状态，对业务并没有实际作用

### 缓存更新机制

- 固定时间过期，被动更新
  
  - **时效性更新机制**：缓存中的数据设置一个过期时间，如果缓存数据过期，那么，我会去提供方查询，这样就相当于将提供方的数据，更新到缓存中了
  
  - **这种是放弃了实时一致性**（商品关注人数、评论数、浏览量）
  
  - **写**：只写数据提供方，不理会缓存。

- **主动更新机制(cache aside)**
  
  - 写：先更新数据库数据，再删除缓存。
  
  - 存在读写不一致的概率很低
    
    - 读的时候，缓存里没有数据
    
    - 读的时候，有写在同时进行
    
    - 读的时长大于写操作（不那么容易发生）
    
    - 读写操作同时发生时，读到的是旧值50%

- **双写一致性**
  
  - **更新缓存，更新数据库**。这样只会造成数据不一致，缓存成功，数据提供方失败，更糟糕
  
  - **更新数据库，更新缓存**。有缺点，但是稍微可取
    
    - 缺点：当多线程同时更新数据时，导致缓存中数据是旧数据
      
      - 空干活，经过复杂的计算，给缓存设置值，但是用的少，浪费了资源。
  
  - **删掉缓存，更新数据库**。
  
  - **删除缓存，更新数据库**。这种会存在问题，造成数据不一致。
  
  - **延迟双删**：删除缓存，更新数据提供方，睡眠一段时间（根据实际业务取值），再删除缓存。
    
    - 如果第二次删除失败了，怎么办？重试一下。
      
      - 自己写重试代码，没问题。自己挂了呢？
      
      - 转移风险？重试组件？消息队列重试

- **Read/Write Through**
  
  - 直接将结果写入缓存，在从缓存同步到数据提供方。调用方只需要和缓存交互。
  
  - 写成功的标识：缓存成功，数据提供方写入成功。这两个是一个事务。TCC
  
  - 缓存预热，命中率低，慢慢命中率才高
  
  - 保障：缓存非常可靠，如果缓存不可靠，则会存在风险

- **Write Behind**
  
  - 在上面做了升级，异步写入到数据提供方。加入消息队列，保证最终一致性。

## 清理机制

- 将命中率很低的数据清理掉，以提高缓存命中率为目标。

- 过去访问多的，未来访问也多。

- 最近被更新的，未来访问的也多

- 过期全部清理，要求缓存中的数据都有一个声明周期，有效期

### 时效性清理

- 轮询有效清理：额外开启一个程序，定期扫描所有的数据的有效期，到期了，就将过期数据干掉

- 自动失效清理：cookie。自动清理的本质就是上面的轮询清理

### 数目阈值

- 记录数据的条数

- 每条记录的大小

- FIFO：先进先出，队列大小是10

- LRU：近期最少使用。数据访问次数，访问的数据放头部，删尾部

> 如果空间充足，则缓存更多的数据。如果空间不够，再回收空间，把空间让出。
> 
> **垃圾回收 -> 软引用**
> 
> 强引用：只要被引用，就不会被回收。内存不足时，哪怕自己挂掉，也不会回收
> 
> 软引用：空间不足时，才会被回收
> 
> 弱引用：发生在每次GC, 
> 
> 虚引用：不确定回收时间

### 实战

- 时效性清理 + 数值阈值式 = 1；过期就干掉

- 密集查询，导致空间急剧增大。

> 不建议：只用软引用，缓存的存活与否，从业务逃脱，业务控制不了。

## 缓存风险点

每增加一个环节，就多一个风险。

### 缓存穿透

数据从缓存中获取不到，从数据提供方也获取不到，即这个数据不存在，被称为缓存穿透。这时就会导致数据库的压力。

- 无效的调用，增加了数据提供方的压力，缓存基本无效

#### 解决方案

- 在缓存中，缓存一份空数据。key有值，value为空

### 缓存雪崩

大量缓存突然失效，引发的数据提供方压力骤增。

#### 数据阈值式清理

阈值比较低的时候会出现雪崩的现象。如果阈值高，可以缓解。因为这中方式是逐个失效的。

#### 时效式清理：

会造成缓存雪崩。过期时间到了之后，导致大量的key失效。这种应该避免缓存在同一时刻失效。

> 过期时间=固定时间 + 随机值

#### 软引用清理

当空间紧张的时候，缓存占据的空间会被回收。

单纯的软引用无法解决。

- lru: 对经常访问的数据建立强引用

### 缓存击穿

有数据提供方兜底，不叫穿透。

- lru：高频访问的数据，大概率在前面 fifo

> read/write through 、write behind 更新机制，这个时候缓存中一定会存在数据，这种情况不会造成击穿。

> cache aside：有一个节点，缓存被删除，可能会发生缓存击穿。

### 缓存预热

在启动系统的时候，提前加载一些数据。对缓存数据进行预加载，这样可以保证缓存的命中率一直保持比较高的状态。

缓存服务启动后，脚本直接灌入。(init)

#### 时效式清理机制：

这种方式会造成缓存重复的预热。

### 实践

清理机制 + 更新机制，针对缓存，共同考虑。

### 缓存的位置

需要缓存的数据，一定要靠前，想要系统性能好，缓存一定要趁早.

前置模块：减少和后端通信的成本

后置模块：公共模块，尽量使用这种方式

## CDN静态缓存

- 静态资源：页面，图片

- 数据：重点：地名，字典，行业分类，统计局那些标准化的数据。三级联动。广义：与用户个体无关的具体通用性的数据，都可以作为静态数据。

## 服务端缓存

redis，localcache, guava

## 数据库缓存

操作完业务，需要做统计，非实时的数据，让他后置。

- 中间表

- 字段冗余

## 写缓存

写缓存：调用方和数据处理方之间。

- 目的：减少巨量调用操作方对数据处理方的冲击。

- 使用场景：削峰，可以采用消息队列的方式。

### 写缓存收益

引入写缓存之后，则对应的处理时间变更为：

(写缓存时间 + 缓存中数据向后传递的时间 + 原始时间)

- 从用户的角度来看：目标用户的响应时间降低了

### 与读缓存的对比

- 读缓存：是以缓存命中率的数据替代数据提供方的操作

- 写缓存：通过增加额外的花费的时间，来延迟数据处理的工作

### 实践

- redis：发布订阅

- 消息队列：发布订阅

- 数据库：先生数据，再进行统计。耗时的&对实时性要求不高的，后置。

### 适合场景

> 请求峰谷值变化明显&对实时性要求不高的系统中。

- 抢购系统

- 竞品系统

- 秒杀系统

- 抢红包系统

### 缺点

- 实时性不高

### 场景

> 大厂：平峰：正常处理；峰值超过阈值的时候，触发写缓存。

- **降级**：微服务的降级组件处理实现

- **灰度发布**：配置灰度规则（规则中，包含了请求的阈值，调用不同的系统）
