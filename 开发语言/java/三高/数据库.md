# 数据库

## 设计

- 先设计关系  ->  设计对象? 
  
  - 这么做的好处：**扩展性高**
  
  - 项目工期不急，稳定性要求高，扩展性要求高。

- 先设计对象 -> 关系?
  
  - 这么做的坏处：比较被动，扩展性不高
  
  - 这么做的好处：好理解

> 重点考虑底层数据关系，辅助：对象关系

### 设计规范：范式、反范式

反范式：是修正严格范式带来的影响，并不是推翻范式的定义。

> 遵循规范，然后根据业务，在做反范式。

### 范式

目前关系型数据库一共有6种范式，按照级别从低到高分别是：

- 1NF(第一范式)

- 2NF(第二范式)

- 3NF(第三范式)

- BCNF(巴斯-科德范式)

- 4NF(第四范式)

- 5NF(第五范式)

数据库设计范式设计越高阶，冗余度就越低，高阶范式一定满足低阶范式的要求。

#### 数据表中的键

范式的定义会使用到主键和候选键(因为主键和候选键可以唯一标识元组)，数据库中的键由一个或者多个属性组成

- 超键：能唯一标识元组的属性集叫做超键。又叫做超码。

- 候选键：如果超键不包括多余的属性，则这个超键就是候选键，就是说候选键一定是超键（候选码）

- 主键：用户可以从候选键中选择其中一个作为主键

- 外键：如果数据表T1中的某属性集不是T1的主键，而是另外一张表T2的主键，那么这个属性集就是T1的外键

- 主属性：包含在任一候选键中的属性成为主属性

- 非主属性：跟主属性相对

#### 1NF(第一范式): 数据库表中的任何属性都是原子的，不可再分

该范式主要说的是，任何DBMS都会满足1NF的要求，除非在设计的时候一个属性X, 属性Y是X的前半段，属性Z是X的后半段，属性Y和Z没有任何使用意义。

> 一个字段是否符合第一范式，主要是看业务：
> 
> 例如：姓名
> 
> 如果业务中需要显示李同学，王同学时，这个时候存为一个字段就不符合第一范式。这个时候姓名就需要将姓和名分开保存。需要从业务触发。

#### 2NF(第二范式)：要求数据表里的非主属性都要和这个数据表的候选键有完全的依赖关系

> 确保表中的每列和主键相关。
> 
> 如果不满足第二范式，就会产生很多的冗余数据和数据不一致问题。

这里有一个不满足2NF的例子：

假设现在有一张球员比赛表，里面包含了：姓名、年龄、比赛编号、比赛时间、比赛场地这些属性。这里的候选键和主键都是(球员编号，比赛编号)，可以通过这个候选键决定其他的属性：

（球员编号，比赛编号）--> （姓名，年龄，比赛时间，比赛场地）

但是这个表满足2NF,因为还存在下面的关系：

（球员编号）---> （姓名，年龄）

（比赛编号）--->  （比赛时间，比赛场地）

也就是说候选键的部分字段决定了非主属性，那么这样会产生一下问题：

1. 数据冗余：球员可以产生多场比赛，那么球员的姓名和年龄就重复了多次。同样，一场比赛有多个球员参与，比赛时间和场地就重复了多次

2. 插入异常：联盟新增了新球员，但是还在休赛期，比赛相关的字段就插入异常。就是候选键部分字段以及他们决定的非主属性有数据，但是候选键其他部分的字段以及其他非主属性还未产生数据时，就插入异常

3. 删除异常：如果还有一场比赛只有一个球员参与，这个球员这个赛季退役了，删除这个球员的时候同时也删除了这场比赛数据

4. 更新异常：当一个球员的年龄变化了，需要更新这个球员参加的所有比赛的行

5. 总的来说，第一个问题导致了后面3个问题，因为数据冗余，导致数据的增删改查

为了满足2NF，则可以修改为：

> 球员表和比赛表，然后新增球员和比赛的关系表

#### 3NF(第三范式)：在满足2NF的同时，对任何非主属性都不传递依赖于候选键（非主属性不依赖于其他非主属性）

> 确保每列都和主键相关，而不是间接相关。第三范式是为了消除非主属性对候选键的传递依赖。

![](C:\Users\自来也\AppData\Roaming\marktext\images\2023-09-06-09-32-57-image.png)

> 在实际业务场景中，我们并不会这么去拆分。在生产环境中，往往会用
> 
> - 代码中引入字典
> 
> - 函数计算。这个函数的输入值是年龄，输出是是否成年

从性能上考虑：需要维护年龄关系表，是有消耗的。维护代码中判断，也是有消耗的。

#### BCNF 巴斯范式

每个属性都不依赖于非主属性。

假设：学习班级号中的序号，由姓名首字母、插入时间来排序。

![](C:\Users\自来也\AppData\Roaming\marktext\images\2023-09-06-10-25-46-image.png)

性能：insert还要update, 没必要，设计上的不合理，导致操作上的性能低

因此，上面的版本可以修改为：

![](C:\Users\自来也\AppData\Roaming\marktext\images\2023-09-06-10-27-11-image.png)

> 在这个过程中，主键是慢慢明确的。
> 
> 插入：先插入学生表，在插入班级序号表。插入班级序号的时候，可以通过写延迟，降低平均响应时间。

#### 4NF(第四范式)：禁止主键和非主键有一对多关系

![](C:\Users\自来也\AppData\Roaming\marktext\images\2023-09-06-10-34-11-image.png)

> 生产中：逗号隔开字符串，将所有的电话存在一列之上。

#### 5NF（第五范式）：每个依赖关系，都有候选键推出。

> 不能被无损的分解成几个更小的不同候选键的不同表。

最常用的场景为：权限设计。

### 反范式

关联查询、链表查询、IO增多，可以采用适当的冗余

> 生产中：订单表中存储商品名称信息，如果完全按照范式：纠纷。

## 乐观锁

1. 读取被操作对象，记录某个特征信息

2. 拿着对象，进行业务逻辑处理，得到新的对象

3. 向数据库写回，新的对象

4. 校验特征信息

5. 如果一致，写回数据库；如果不一致，回退并重试

### 特征信息策略

- 版本号：增加一个策略，值：时间戳或者自增id

> 如果属性的值比较丰富的话，可以用被更新的属性。

- 已经上线了，一个表10个字段，原来没有考虑锁，发现出现了写冲突
  
  - 最快的解决办法：全部属性当特征。生成hash数据
  
  - 增加几行
  
  - 读：所有字段做hash
  
  - 执行业务逻辑
  
  - 写：校验hash

> 乐观锁用于极少修改，减少操作方重复尝试的概率。

## 悲观锁

### 锁类型

- 行锁： where id = 1

- 页锁：锁定相邻的记录

- 表锁：update set xxx = 1, 不写where条件

### 死锁

先读后写，U锁；更新锁

加了u锁，我可以操作，**但是其他对象不能加u,x, 只能加s锁**，这种mysql并不支持。

#### 原则

加对共享性影响最小的锁，能加S锁，不加U锁；能加U锁，不加X锁。最大限度保证被操作对象的并发性能，最小知道原则。

#### 产生死锁原因

产生死锁有以下四个条件，然后按照条件逐一解决：

- **互斥条件**：钥匙，一个人拿了，另外一个人不能拿

- **不剥夺条件**：也就是拿了钥匙的人，没人能让他放手

- **请求和保持条件**：有了一个资源，再请求另外一个资源

- **循环等待条件**：环状等待现象

#### 解决方法

打破以上四个条件任何一个：

- **打破互斥条件**：经常发生在写操作的时候，X锁，而此时，不能加其他的锁，资源很难共享。<mark>这种可以通过乐观锁的方式解决</mark>。

- **打破不剥夺条件**：
  
  - 要求：操作方在已获得资源条件下，如果要申请别的资源，如果申请失败，则释放已获得的资源，让其他线程可以获取我已经获得的资源。

- **打破请求和保持条件**：保持、请求只保留一个。
  
  - 只请求不保持：只能持有一个资源，要请求其他资源，则放弃已有资源
  
  - 只保持不请求：同时拥有，别再去找其他资源了

- **打破循环等待条件**：按照顺序获取资源，在获取资源时，排序。

#### 程序中如何定位死锁

- 看程序静止的点。在JAVA中线程会处于**BLOCKED**状态或者**WAITING**状态

- 数据库死锁如何定位：查看死锁日志

## 事务

#### ACID:

- A: WAL

- C: 外键，唯一索引

- I：锁, MVCC

- D：逻辑操作。一共要写两行，我只写了一行，结果宕机了，从日志找。这样通过逻辑和物理层面保证。

在三高项目的时候，需要使用`I隔离性来实现`，**隔离越小，并发越高，系统开销更低**。

### 隔离级别

直接给被操作对象加X锁，就直接实现了串行化。性能急剧下降。

> 为了性能，允许有一些并发问题。隔离级别不是解决隔离性和事务并发之间的矛盾，只是在两者之间，取的平衡。

事务隔离本质：就是让穿行。

#### 读未提交(Read Uncommit)

读取到了其他事务未提交的数据。

**读取**：查询时，不加锁

**写操作**：在更新或者插入数据时，**写的瞬间加S锁**，事务结束释放。

#### 读已提交(Read Commit)

一个事务能够读取到其他事务已提交的数据。这种隔离级别会造成不可重复读。

**读**：S锁，读完之后立即释放。因为上了S锁，其他事务无法上X锁，因此可以避免脏读

**写**：X锁，事务结束才释放。这样避免了其他的事务读取到未提交的数据

#### 可重复读(Read Repeatable)

**读**：S锁，事务完成释放锁

**写**：X锁，事务完成释放锁

> 读未提交、读已提交、可重复读都是行锁。

#### 串行化(seriable)

**写**：整个表X锁

**读**：整个表S锁

### 自建事务

原则：第一个成功，第二个出错，让第一个回滚。

- 先操作本地数据：先执行不会对外界造成影响的操作(可以回滚的操作)

- 在调用方法：后执行不可回滚的操作或者不能回滚的操作，不可回滚的操作只能有一个。

## 数据库量大后的优化

随着数据量的增多，sql语句效率会下降。

- 加索引：提升查询的效率

- 表分区

- 分库分表

- 读写分离

### 表分区

#### 分区的优点：

- 不影响业务

- 放不同磁盘上

- 可以备份、恢复、逐步进行

#### 分区的缺点

- 表分区最大的分区数量为1024个，当业务发生跨区查询的时候，会影响查询性能(**分区数据合并性能**)

#### 分区方法

- range：根据属性值范围分区

- list

- Hash: 散列分区，可以多个列计算散列值分区

- key：只能按照一个属性分区

#### 注意点

1. 结合查询规则，尽量保证查询只会落到一个分区中。减少跨区合并的开销

2. 下标寻址。在做查询的时候，尽量将查询条件放到where条件中

> 基于前面的并发、并行的思想，对读写操作进行分流。

### 分库分表

1. 将表整体分库，这个不常用

2. 将每个表，分到多个库中，因为数据表少了，便于检索。同时也能使得行锁和表锁的范围。

#### 表拆分

- 水平拆分：多条记录拆分到不同的表中，拆分后的多个表，数据结构一样。

- 垂直拆分：拆出来的表，只包含原表中的部分属性。

#### 场景

场景：经常获取数据表的全部信息 则采用水平拆分

原则：避免夸表操作。

#### 实现

mycat, shardingsphere



### 读写分离

X锁，阻止了其他操作的读和写。

S锁： 可以并发读

因此采用了将读和写分开，保证读不受写的约束。还可以将多个写并发执行。

> 这种适用于**读多写少**。多少写多的提升比不明显。

#### 注意的点

- 路由操作
  
  - 路由： select的时候路由到读库上
  
  - add update delete create 路由到写库上

#### 主从复制

确保主从数据一致性。将主库的数据同步到从库，需要避免：对从库的写操作，不让从库出现X锁，否则就失去了读写分离的意义。

##### binlog

1. 主库开启日志记录功能，写操作记录在binlog中

2. binlog被发到从库中，写入从库的RelayLog

3. 从库解析RelayLog, 重现数据

**STATEMENT模式**：在binlog中记录的是操作语句，如果一些设计到当前时间的函数,now(), 则可能会产生数据不一致问题。

**`Row模式`**：binlog中记录的是记录信息

**mixed模式**：操作和记录的混合，主要写入操作语句，必要的时候，则写入的是记录(大部分情况下)



##### 主从复制延迟问题

日志经过记录->传输->解析之后，从从库中无法读取到最新数据的问题。

- **异步复制**：降低写的响应时间，但是可能导致数据不一致或丢失

- **半同步复制**：写入主库后，日志至少送到一个从库上，写才返回。
  
  - 谷歌开发了mysql半同步插件

- **全同步复制**：写入数据的时候，将写入的操作同步到所有的从库，在返回响应。

##### 如何使用

1. 写入主库

2. 在储存里留一个记录，记录包含了唯一标识

3. 当读发生的时候，中间件需要判断记录是否已经存储到了从库中
