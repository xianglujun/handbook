# 并行、并发

服务的搭建中，就是围绕并行和并发来开展。

- 并行：同一时刻，多个任务同时执行

- 并发：任务交替进行

## 并发的处理方式

### 集群

- 集群中每个节点都是同质的，(同样的配置，同样的运行程序，对外提供同样的服务)

- 修改同样的存储

- 内存中的信息，可能会导致不一致问题

- 如果数据量小，直接在内存解决(guava)。开源组件，很多都用内存解决

### 单一服务节点集群

- 数据会丢

- 容错性差

### 信息共享节点集群

- 锁、分布式锁

- 优点：提升集群的计算能力。

- 缺点：存储会成为瓶颈

### 信息一致节点集群

- 盘古：保证不同地区的数据同步

- 在一定时间之后，能读取到变更，根据变更时间的长短，将一致性分为积累：
  
  - 强一致性
  
  - 最终一致性

## 2. 分布式系统

- 将单体应用进行拆分，如果子应用不够用，不能经受住并发，那么就做集群

- 应用有从属关系。下订单请求

## 3. 微服务

- 应用和应用之间，都是独立的，可以对微服务进行组装

- 保证接口不变，其他随意。

- 从服务的整体来说的并发，根据不同的场景，都是混用的。

## 4. 服务器内并发

### CAP

分布式系统起点：一致性、可用性、分区容错性

**P**: 分区容错性，分区和容错，因为网络有8大谬误

- 网络是可靠的

- 没有延迟

- 带宽无线

- 网络安全

- 拓扑结构不变

- 只有一个管理员

- 传输代价没有

- 网络是同构的

**C**: 一致性分为哪几类

- 强一致性

- 弱一致性：能容忍部分或全部，看不到最新的数据

- 最终一致性：经过一段时间，能看到最新的数据

**A**：可用性

> cap一般不用业务做说明。一般会在做中间件的时候才需要cap。在互联网中大部分场景下： A > C

#### 应用场景

- 舍弃P：单点数据库。但是考虑数据库集群的时候，就要考虑P

- 舍弃A：zookeeper

- 舍弃C：eureka， CoachDB

> AP舍弃C, 舍弃强一致，保证最终一致性。通过最终一致性，兼顾了三个特性。

### 内部并发

- 线程、线程池
  
  - > 分配资源、开销、资源、环境、耗时
  
  - 目的2个：
    
    - 提升效率：io读数据、cpu计算结果、然后io输出
    
    - 实现异步：主线程提前释放，后面还需要一个耗时很长的任务。降低了平均响应时间，此时并发就上来了。主线程实现主要的任务，不重要的任务靠后。发邮件、记日志、与第三方的交互(信息的上报)
  
  - 现成计算公式：
    
    - **线程数 = CPU核数 * cpu使用率 * (1 + w/c)**
      
      - w/c 相当于 等待时间/计算时间
      
      - 时间段： 1s 0.8s在干活，则使用率为80%。 0.3/2=15%
      
      - 实际经验： 70%,则开始预警。
      
      - 平均负载：top 1min, 5min, 15min loadaverege
      
      - 平均负载大于0.7 * 核数，要开始排查原因，防止系统恶化
    
    - 公式2： 线程数 = cpu核数 / (1 - 阻塞系数)
      
      - 计算密集型: 0
      
      - IO密集型：1
      
      - 阻塞系数 = w / (w + c)
  
  > 实际中，先定一个数，然后再压测，以压测数据为准。

- 进程
  
  - docker、不同端口启动(主要是利用资源的隔离性)

- 协程：线程中的线程。java官方并没有推出，一个方法被阻塞，他执行另一个方法。
  
  - quasar：jar包
