# 数据库与NoSQL互补

## NoSQL

NoSQL发展到现在，十几年间，出现了多种类型:

- `Redis, LevelDB`: 主要以KV存储。这种数据库的特点`极高的读写性能`，`一般对性能有比较高的场景会使用`
- `Hbase, Cassandra`: 这样的列式存储数据库。这种数据库的特点是数据不像传统数据库以行为单位来存储。而是以列的来存储，适用于一些离线数据统计的场景。
- `MongonDB, CouchDB` : 这样的文档型数据库。这种数据库的特点是Schema Free, 数据表中的字段可以任意扩展。 

> NoSQL本身缺乏事务以及索引灵活性等，在实际场景中，只能作为一种场景补充实现。

## 使用NoSQL提升写入性能

数据库系统大多的是传统的机械磁盘。对于机械磁盘访问方式有两种：

- 随机I/O
- 顺序I/O

`随机I/O`需要花费时间做昂贵的磁盘寻道，一般来说，它的读写效率要比顺序IO小两到三个数量级，所以我们想要提升写入的性能，就要尽量减少随机IO.

> 在InnoDB引擎中，采用B+数作为索引存储方式，而Mysql主键是`聚簇索引`，既然数据和索引存放在一起，那么在数据插入或者更新的时候，就需要找到对应数据数据所在的页，并写入数据，然后刷入到磁盘中，这就产生了随机IO. `如果一旦发生了页分裂，就不可避免会做数据移动，也会极大地损耗写入性能。`

## NoSQL数据库是怎么解决随机IO的呢？

在常见的NoSQL数据库都使用的`基于LSM树的存储引擎`，这种算法使用最多。

> LSM树(Log-Structed Merge Tree)牺牲了一定的读性能来换取写入的高性能，Hbase, Cassandra, LevelDB都是使用这种算法作为存储的引擎。

### 实现原理

- 数据会先写入`MemTable`的内存结构中，在`MemTable`中数据是按照写入的Key来排序的。
- 为了防止MemTable里面的数据因为机器掉电或者重启而丢失，一般会通过写`Write Ahead Log`方式将数据备份在磁盘上
- 当`MemTable`数据达到一定规模时，会将数据写入到`SSTable(Sorted String Table)`
- 当`SSTable`达到一定数量时，会将`SSTable`进行合并，减少文件数量。在合并时，依然保证数据的有序性
- 当`LSM`树里面读取数据是:
  - 首先从`MemTable`中查找数据
  - 如果没有找到，再从`SSTable`中查找数据
  - 因为存储数据是有序的，所以查找的效率是很高的，只是因为数据被拆分成为多个`SSTable`, 所以读取的效率低于`B+`索引。

## 提升扩展性

NoSQL相对于传统管系统行数据而言，具备了良好的扩展性。

对于传统关系型数据库，在扩展性方面具备一下缺点:

- 在扩展数据库是，需要以分表分库的方式进行拆分，但是拆分完成之后，需要将原有数据重新整理，并存储到新的数据库节点中
- 在数据迁移过程中，带来了许多不可控因素，出错成本太高。



### MongonDB在扩展性方面具备一下特点

- `Replicas`: 副本集，
  - 通过将数据拷贝为多分保证当主节点挂掉后数据不丢失。
  - Replicas节点可以分担读请求。
  - Replica中有主节点来承担写请求，并且把数据变动记录到`oplog`里;
  - 从节点接收到oplog后就汇修改自身的数据以保持和主节点一直
  - 自动选主功能，能够提供持续数据写服务
- `Shard`：分片
  - 将数据按照某种规则拆分成多分，存储在不同的机器上
  - 实现该功能需要有三个角色功能实现：
    - `Shard Server`: 实际存储数据的节点，是一个独立的Mongod进程
    - `Config Server`: 也是一组Mongod进程，主要存储一些元数据，比如分片存储位置，以及分片下的数据信息
    - `Route Server`: 它不实际存储数据，仅仅作为路由使用，他从`Config Server`中获取元数据后，将请求路由到正确的`Shard Server`中。
- `负载均衡`：
  - 当MongoDB 发现Shard之间数据分布不均匀，会启动`Balancer`进程对数据做重新分配，最终让不同Shard Server的数据量可以尽量的均衡。
  - 当`Shard Server`存储空间不足需要扩容时，数据会自动被移动到新的`Shard Server`上，减少了数据迁移和验证的成本。