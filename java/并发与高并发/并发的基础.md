# 并发的基础

## CPU的多级缓存
1. 为什么需要CPU cache
> CPU频率很快，以至于主存无法跟上，这样在处理器始终周期内, CPU常常需要等待主存, 浪费资源。所以cache的出现, 是为了缓解CPU和内存之间速度不匹配问题。(结构: cpu -> cache -> memory)

2. CPU cache有什么意义
a. 时间局限性: 如果某个数据被访问, 那么在不久的将来它很可能被再次访问
b. 空间局部性: 如果某个数据被访问,那么与它相邻的数据很快也可能被访问。

### 缓存一致性(MESI)
- 用于保证多个CPU cache之间缓存共享数据的一致。

### 乱序执行优化
- 处理器为提高运算速度而做出违背代码原有顺序的优化
- 可能会导致代码执行顺序不一致

## Java内存模型(Java Memory Model, JMM)
- JMM是一种规范，规范了JAVA虚拟机与计算机如何协同工作
- 规定了一个线程,如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步到共享变量。

### 同步八种操作
- `lock(锁定)`: 作用于主内存的变量,把一个变量标示为一条线程独占状态。
- `unlock(解锁)`: 作用于主内存的变量, 把处于一个锁定状态的变量释放出来, 释放后的变量才可以被其他线程锁定。
- `read(读取)`: 作用于主内存的变量, 把一个变量值从主内存传输到线程的工作内存中, 以便随后的load动作使用
- `load(载入)`:作用于工作内存变量, 它把read操作从主内存中的到的变量值放入工作内存的变量副本中
- `use(使用)`: 作用于工作内存的变量,把工作内存中的一个变量值传递给执行引擎
- `assign(赋值)`: 作用于工作内存的变量, 它把一个从执行引擎接收到的值赋值给工作内存的变量
- `store(存储)`: 作用于工作内存中的变量, 把工作内存中的一个变量的值传送到主内存中, 以便随后的write操作
- `write(写入)`: 作用于主内存的变量, 它把store操作从工作内存中一个变量的值传送到主内存的变量中

### 同步规则


## 并发的优势与风险
- 优势
  - 速度: 同时处理多个请求, 响应更快: 复杂的操作可以分成多个操作同事进行
  - 设计: 程序设计在某些情况下更简单, 也可以有更多的资源
  - 资源利用: CPU能够在等待IO的时候做一些其他的事情
- 风险:
  - 安全性: 多个线程共享数据时可能会产生于期望不相符
  - 活跃性: 某个操作无法继续进行下去时,就汇发生活跃性问题, 例如死锁, 饥饿等问题
  - 性能: 线程过多时会使得: CPU 频繁的切换,调度时间增多;同步机制: 消耗过多的内存
