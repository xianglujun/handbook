# 线程安全性
# 原子性
同一时刻只能有一个线程进行访问
- Atomic包
- CAS算法
- synchronized
- Lock

# 可见性
一个线程对主内存的修改能够及时的被其他线程检测到
- synchronized
- volatile

# 有序性
- Java内存模型中, 允许对编译器和处理器指令进行重排序, 但是重排序过程中, 不会影响到单线程程序的执行, 却会影响到多线程并发执行的正确性
- volatile, synchronized, Lock

## Happen-before原则
  - 程序次序规则: 一个线程内, 按照代码顺序, 书写在前面的操作先行发生于书写后面的操作(看起来是按照代码顺序执行的.`保证程序在单线程代码中结果的正确性`)
  - 锁定规则: 一个unlock操作优先发生于对后面对同一个锁的lock操作
  - volatile规则: 对一个变量的写操作优先发生于后面对这个变量的读操作
  - 传递规则: 如果操作A优先发生于操作B，操作B优先发生于操作C，那么操作A优先发生于线程B
  - 线程启动规则：Thread对象的start()方法优先发生于此线程的每一个动作
  - 线程终端规则: 对县城interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
  - 线程终结规则: 线程中所有的操作都先行发生于线程的终止检测,我们可以通过`Thread.join()`方法结束, `Thread.isAlive()`的返回值检测到线城市是否已经终结
  - 对象终结操作: 一个对象的初始化完成先行发生于他的finalize方法的开始

> 如果程序的执行规则不能从`Happen-before`原则推到出来, 那么程序就可以对执行进行重排序
