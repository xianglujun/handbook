# 数据误删除怎么处理

## 1. 误删除行数据

对于误删除行数据，可以通过`Flashback`工具通过解析binlog反推出数据的原始状态。例如：

```sql
update ....
delete ....
insert ....
```

通过`flashback`解析binlog出来的结果应该与正常事务实行的顺序相反。

```sql
delete ...
insert ...
update ...
```

### 如何防止误删除

1. 可以通过在mysql配置中新增`sql_safe_update = on`，让用户在更新数据的时候，必须加上where条件
2. 在执行sql的时候，必须要对sql进行审计

> 在恢复数据的时候，我们一般会现在从库上执行恢复操作，这样优先保证数据在从库上没有问题，然后再将从库的内容回复到主库上。

## 误删库/表

在这种情况下，想要恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的备份，并且实时备份binlog.

具体恢复的流程如下：

1. 取出最近一次全量备份
2. 用备份恢复出一个临时库
3. 从日志备份里面，备份时间点之后的日志
4. 把这些日志，除了删除数据外的语句，全部应用到临时库

在这个过程中，有以下几点需要注意:

1. 为了加速数据恢复，如果这个临时表上有多个数据库，可以在使用`mysqlbinlog`命令时，加上一个`-database`参数，用来指定误删表所在的库。这样避免了在恢复数据时还要应用其他库日志的情况。
2. 在应用日志的时候，需要跳过误操作时间点的语句
   1. 如果原实例没有使用GTID模式，只能在应用到包含误删操作时间点的binlog的时候，先用`-stop-position`参数执行到误删除操作之前的日志。然后再用`-start-position`从误操作之后的日志继续运行。
   2. 如果实例使用了GTID模式，假设误操作命令的GTID是`gtid1`, 那么只需要执行`set gtid_next=gtid1;begin;commit;`就先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就汇自动跳过误操作语句。

### 加速方法

在以上的操作中，由于`mysqlbinlog`不能从binlog中过滤出指定的表，因此我么可以创建一个临时实例并设置成为线上备库的从库，然后执行一下操作：

1. 在`start slave`之前，先通过执行`change replication filter replicate_do_table = (table_name)`命令，就可以让临时库值同步误操作的表
2. 这样做可以用上并行复制技术，来加速整个数据恢复过程。

## 延迟复制备库

延迟复制的备库是一种很特殊的备库，通过`change master to master_delay =  n`命令，可以指定这个备库持续保持跟主库有N的延迟。

例如我们将延迟时间设置为3600秒之后，那么在这1个小时内发生了误操作，这个命令还没有在这个延迟复制的备库执行。这是后就可以通过`stop slave`，再通过前面的方法，跳过误操作的命令，就可以回复出需要的数据。

## 预防误删除库/表的方法

1. 我们只给业务开发人员DML权限，不给`truncate/drop`权限，而如果业务开发人员有DDL需求的时候，也可以通过开发管理系统的到支持
2. 即使是DBA团队成员，日志也都规定只使用只读账号，必要的时候才使用有更新权限的账号
3. 在删除数据表之前，必须先对表做改名操作，然后，观察一段时间，确保对业务无影响以后再删除这张表
4. 改表明的时候，要求给表明加固定后缀，然后删除表的动作必须通过管理系统执行，并且，管理系统删除表的时候，只能删除固定后缀的表。

## rm删除数据

对于一个高可用机制的Mysql集群来说，最不怕的就是rm删除数据了。只要不是恶意把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。