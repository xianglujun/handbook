# SQL执行慢原因分分析
一条SQL执行慢主要分为两种情况:
1. 偶尔执行很慢
2. 在数据量不变的情况下, SQL查询一直比较慢

## 偶尔执行很慢
1. 数据库正在刷新脏页数据

> 向mysql数据库插入一条数据或者更新数据时, 优先在`内存`中更新字段的值, 并将数据更新字段写入`redo`日志中, 在数据库空闲时, 再将`redo log`日志持久化到磁盘之中.

> 不过, `redo log`日志容量有限,如果数据库一直很忙, 更新又很频繁, `redo log`日志被迅速的填满, 数据库会暂停其他操作, 优先将`redo log`中的数据同步到磁盘中, 而这个时候，`就会导致我们平时正常SQL语句突然执行的很慢`. 所以，数据库在同步数据到磁盘时, 可能会导致SQL执行慢

2. 执行SQL较长时间未获取到锁

> 当执行SQL需要锁定记录或者锁定表时, 这是正好有其他SQL已将表或者对应的记录锁定，这时就必须等待锁释放后，才能继续执行。

> `show processlist`可以查看线程的等待情况, 并查看当前的状态

## SQL执行一直很慢
1. 没有使用到索引
  - 字段没有加入索引
  - 字段设置索引，但是没有命中
  - 函数操作导致没有用上索引
  - 过滤条件加上了运算操作
2. 数据库索引选择错误
```sql
select * from table where age >100 and age <= 1000
```
主键索引和非主键索引是有区别的,
- 主键索引: 主键索引上会存放整行字段的所有数据
- 非主键索引: 非主键字段存放的则只是`主键字段的值`

2.1 系统对索引扫描和全表扫描选择依据
mysql通过`索引区分度`选择使用索引或者全表扫描, 一个索引上不同的值越多, 意味着出现相同数值的索引越少. 意味着索引的区分度越高(索引字段的重复值与区分度成反比).

我们也把区分度称之为`基数`, 即区分度越高, 基数越大.

2.2 myql获取区分度(基数)的依据
mysql通过`采样`的方式，来`预测`索引基数的。

索引myql可能在采样时, 将索引的`基数`预测很小. 然后，系统可能就会直接走`全表扫描`

> 所以, 由于系统采样的差异导致统计的失误,  导致系统没有走索引, 而是走了全表扫描.

2.3 sql强制走索引
```sql
select * from table force index(a) where age > 100 and age < 1000
```

2.4 查询索引基数和实际是否相符合
```sql
show index from table;

-- 重新统计索引的基数
analyze table t;
```
