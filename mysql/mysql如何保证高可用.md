# mysql如何保证高可用

## 主备延迟

主备切换可能是一个主动运维动作，也可以是被动操作，例如主库所在机器掉电。

### 主动切换

在介绍主动切换流程之前，需要了解一下`同步延迟`，与数据同步有关的时间点主要包含一下三个：

1. 主库Master执行完成一个事务，写入binlog, 这个时间记为: T1
2. 之后将执行语句传给Slave，备库Slave接收到binlog时间记为： T2
3. 备库Slave执行完成事务，记为时间：T3

因此，主备延迟指的就是同一个事务，在备库执行完成的时间和主库执行完成的时间的差值，即：`T3 - T1`

> 查看主从延迟的时间，可以通过命令: `show slave status`
>
> 其中返回结果中，关注 `Seconds_Behind_Master: 0`的值，能够查看主从延迟时间

### seconds_behind_master计算方法

1. 每个事务的binlog里面都有一个时间段，用于记录主库上写入的时间
2. 备库取出当前正在执行的事务的时间段的值，计算它与当前系统时间的差值，的到`seconds_behind_master`

> seconds_behind_master的值时间精度为秒。当主备机器的时间不一致的时候，是否会导致延迟时间不准确？这里是不会的，因为当slave链接到备库的时候，会通过`SELECT UNIX_TIMESTAMP()`函数来获取当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行`second_behind_master`计算的时候会自动扣掉这个值。

## 主备延迟的原因

### 在一些部署的条件下，备库所在机器性能要比主库所在机器性能差

在更新过程中，也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。

> 在主备的工作模式中，主备随时可能发生切换，备库随时可能编程主库。所以主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况

### 备库压力大

一般的想法中，主库提供了写入的能力，那么备库可以提供读能力。比如：

- 运营后台需要分析的语句，不能影响正常业务，所以在备库上执行

在针对从库备库需要处理查询能力时，往往可能导致备库在读上的压力，CPU资源使用率上升，从而影响同步速度，造成主备延迟。

这种情况可以通过以下方式处理：

- `一主多从`：除了备库外，可以多接入几个从库，让从都分担读的压力
- 通过binlog输出到外部系统，例如Hadoop这类系统，让外部系统提供统计类查询能力

> 一主多从的方式大都会被采用。因为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。

### 大事务

在主库上执行事务时，必须要等待事务执行完成才回写入binlog, 在传给备库。当一个事务过大时，由于主库执行的时间较长，会导致从库同步延迟。

#### 一次删除过多数据

我们一般场景中，被要求不要一次性删除太多的数据。因此当删除的数据过多时，会被要求分批次的删除数据，防止因为大事务导致主从延迟。

#### 大表DDL

对于大表的DDL方案，我们可以采用`gh-ost`方案处理。

### 备库并行复制能力



## 如何解决主从延迟

### 可靠性优先策略

![img](.\54f4c7c31e6f0f807c2ab77f78c8844a.png)

在上图中，发生主从切换的流程如下：

1. 判断备库Slave现在`seconds_behind_master`，如果小于阈值(例如5秒)继续下一步，否则持续重试当前步骤

2. 把主库Master改成只读状态，即`readonly=true`

3. 判断备库Slave的`seconds_behind_master`的值，直到这个值变成0为止

4. 把备库Slave改成可读写状态，即`readonly=false`

5. 把业务请求切换到备库Slave

在这个步骤中，有一段时间是处于不可用状态。当发生延迟后，Master和Slave都会处于readonly状态，直到第5步完成才能回复。



### 可用性优先策略

在以上的步骤中，如果我们将步骤4和步骤5提到最先执行，这是就不会存在不可用的时间。但是会带来数据不一致的情况发生。

```sql
CREATE TABLE `t` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `c` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(c) values(1),(2),(3);
```

![img](.\3786bd6ad37faa34aca25bf1a1d8af3a.png)

加入以上流程设置`binlog_format=mixed`时的切换流程和数据结果。现在一起分析一下上面的切换流程：

- 步骤2中，主库A执行完Insert语句，插入了一条数据(4, 4), 之后开始进行主备切换。
- 步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用`插入c=4`这个中转日志，就开始接受客户端`插入c=5`的命令。
- 步骤4中，备库B插入了一行数据(4, 5), 并且把这个binlog发送给A
- 步骤5中，备库B执行`插入c=4`这个中转日志，插入了一行数据（5,4）, 而直接在备库B执行的"插入c=5"这个语句，传到主库A，就插入了一条新数据(5, 5)

最后的结果是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致是由于可用性优先流程导致的。

那么，如果我们还是使用可用性优先策略，但设置`binlog_format=row`又会怎么样呢？

![img](.\b8d2229b2b40dd087fd3b111d1bdda43.png)

因为row格式在记录binlog的时候，会记录新插入的行的所有字段的值，所以最后只会有一行不一致。而且两边的主备同步的应用线程会报出`duplicate key error`并停止。这种情况下，备库B的(5,4)和主库A（5, 5）这两行数据都不会执行。

通过以上分析，可以得到一些结论：

- 使用row格式的binlog时，数据不一致的问题更容易被发现。而mixed或者statement格式的binlog时，数据可能产生不一致，而且很难被发现。
- 主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。

## 如何解决？

应该采用`可靠性优先策略`