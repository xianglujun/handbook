# 查询很多对数据库的影响

## 全表扫描对server层的影响

InnoDB的数据是保存在主键索引上的，所以全表扫描实际上直接搜啊秒表t的主键索引。当执行一个没有查询条件的SQL,所以查询到的每一行都可以直接放到结果集里面，然后返回给客户端。

### 取数据和发数据流程

- 获取一行，写到`net_buffer`中。这块内存的大小是由`net_buffer_length`定义的，默认为`16k`
- 重复获取行，直到`net_buffer`写满，调用网络接口发出去
- 如果发送成功，就清空`net_buffer`, 然后继续去下一行，并写入`net_buffer`
- 如果发送函数返回`EAGAIN`或`WSAWOULDBLOCK`, 表示本地网络栈(socket send buffer)写满了，进入等待、直到网格栈重新可写，再继续发送。

### Mysql查询语句状态变化

- MySQL查询语句进入执行阶段后，首先吧状态设置为`Sending data`
- 然后，发送执行结果的列相关信息给客户端（meta data）
- 然后再继续执行语句的流程
- 执行完成后，吧状态设置为空字符串

## 全表扫描对InnoDB的影响

在InnoDB中，影响最大的就是`Buffer Pool`的作用，主要是：

- 当Buffer Pool中的数据也是最新的时候，则不需要再去读磁盘，可以直接将Buffer Pool中的数据返回
- Buffer Pool能够加速查询的作用，但加速作用收到`内存命中率`的影响。

> InnodDB Buffer Pool的大小由参数`innodb_buffer_pool_size`确定，一般建议设置成可用物理内存的`60%~80%`

### InnoDB中LRU算法

InnoDB管理Buffer Pool的LRU算法，是用链表来实现的。

![img](.\e0ac92febac50a5d881f1188ea5bfd65.jpg)

- 在上图中状态1里，链表头部是P1, 表示P1是最近刚刚被访问过的数据页；假设内存里只能放下这么多内存页
- 这时候一个读请求访问P3，因此变成状态2，P3被一到最前面
- 状态3表示，这次访问的数据页是不存在与链表中，所以需要在Buffer Pool中新申请一个数据页Px, 加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会请空链表末尾Pm这个数据页的内存，存入px的内容，然后放到链表头部。
- 从效果上看，就是最久没有被访问的数据页pm,被淘汰了

![img](.\21f64a6799645b1410ed40d016139828.png)

实际上mysql对LRU算法做了改进。

在InnoDB实现上，按照5:3的比例吧整个LRU链表分成了young区域和Old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表5/8处。也就是说，靠近链表头部的5/8是young区域，靠近链表尾部的3/8是old区域。

改进后的LRU算法执行流程编程了下面这样：

- 状态1要访问数据P3, 由于P3在young区域，因此和优化前的LRU算法一样，将其移动到链表头部，变成状态2
- 之后要访问一个新的不存在与当前链表的数据页，这时候依然是淘汰数据页Pm, 但是新插入的数据也Px，是放在LRU_old区域
- 处于old区域的数据也，每次被访问的时候要做一下判断:
  - 若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部
  - 如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数`innodb_old_blocks_time`控制的。其默认值是1000, 单位毫秒。