# 读写分离有那些坑

## 目的

读写分离的主要目的在于分摊主库的压力。目前数据库读写分离有两种工作模式：

- 客户端存储所有数据库信息, 有客户端完成
- 在客户端与mysql之间新增Proxy层

## 如何解决主从不一致，导致过期读问题

- 强制读取主库方案
  - 对于必须要拿到最新结果的请求，强制分发到主库上
  - 对于可以读到旧数据的请求，才将其发送到从库上
- sleep方法
  - 该方案为在更新数据信息后，读从库之前先sleep一下，具体就是"select sleep(1)"
  - 该方案存在不精确的行为，主要包含两个方面:
    - 如果这个查询请求本来0.5秒就可以在从库上拿到正确数据，也会等1秒
    - 如果延迟超过1秒，还是会有过期读的问题
- 判断主备无延迟方案
  - 判断主备有无延迟有三种方式:
    - 每次从库执行查询前，先判断`seconds_behind_master`是否已经等于0.如果还不等于0，那就必须等到这个参数变为0才能执行查询请求
    - 第二种方式为对比位点:
      - `Master_Log_File`和`Read_Master_Log_Pos`，表示的是读到的主库的最新位点
      - `Relay_Master_Log_File`和`Exec_Master_Log_Pos`表示备库执行的最新位点
      - 如果以上两组值完全相同，就表示接受到的日志已经同步完成
    - 第三种方式：对比GTID集合确保主备无延迟
      - `Auto_Position=1`表示这对主备关系使用了GTID协议
      - `Regrieved_Gtid_Set`是备库收到的所有的日志的GTID集合
      - `Executed_Gtid_Set`是备库所有已经执行完成的GTID集合
      - 如果这两个集合相同，也表示备库接收到的日志都已经同步完成。
- 配置semi-sync方法
  - semi-sync半同步机制，做了一下设计:
    - 事务提交的时候，主库把binlog发给从库
    - 从库收到binlog之后，发挥给主库一个ack, 表示收到了
    - 主库收到这个ack以后，才能给客户端返回事务完成的确认
  - 存在的问题
    - 在一主多从的时候，在某些从库执行查询请求会存在过期读的现象
    - 在持续延迟的情况下，可能出现过去等待的问题
- 等主库位点方案
  - 等待主库位点主要通过SQL的方式实现: `select master_pos_wait(file, pos[, timeout])`
    - 首先该命令是在从库上执行
    - 参数file和pos指的是主库上的文件名和位置
    - timeout可选，设置为正整数N表示这个函数最多等待N秒
  - 该条命令会返回以这个整数N，表示应用完file和pos表示的binlog位置, 执行了多少事务
    - 如果执行期间，备库同步线程发生异常，则返回NULL
    - 如果等待超过N秒，就返回-1
    - 如果刚开始执行的时候，就发现已经过了这个位置，则返回
- 等GTID方案
  - 通过`select wait_for_executed_gtid_set(gtid_set, 1)`
    - 等待，直到这个库执行的事务中包含传入的的gtid_set, 返回0
    - 超时返回1
  - 该方式需要启用GTID模式，通过参数`session_track_gtids=OWN_GTID`, 然后通过接口`mysql_session_track_get_first`从返回包解析出GTID的值.