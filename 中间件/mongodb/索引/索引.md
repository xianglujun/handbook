# 索引

## 1. 索引概念

在mongodb中，索引能够使查询更加高效。在没有索引时，查询必须遍历整个集合。索引是一个特殊的数据结构，存储了文档的部分字段数据，并能够快速执行遍历操作。索引不仅存储了索引字段具体的值，同时存储的值，也按照一定顺序排列。索引的有序性能够快速的执行等值和范围查询，并且通过索引能够保证在返回数据时的顺序性。

### 1.1 索引分类

所以主要包含了一下几种分类：

- Single Field: 单字段索引

- Compound Index: 组合索引，针对多个字段创建索引

- Multikey Index: 针对数组的索引方式

- Geospatial Index: 针对地理位置索引

- Text Index: 全文索引

- Hashed Index: hash索引

### 1.2 索引属性（Index Properties）

- Unique Indexes: 唯一索引，主要保证字段的值不会有重复值。除了唯一性约束，唯一索引可以和其他索引在功能上互换。

- Partial Indexes: 部分索引，部分索引紧紧为集合中满足指定表达是的文档建立索引，通过索引文档子集，部分索引具有更低的性能要求，并降低了创建索引和维护索引的性能成本。部分索引提供了稀疏索引的超集，应该优先于 稀疏索引。

- Sparse Indexes：稀疏索引，稀疏索引保证了只有索引字段会被存储在索引的数据结构中，自动跳过了没有添加索引的字段。稀疏索引可以配合唯一索引实现数据的重复插入和跳过缺失索引字段的文档数据

- TTL Indexes: TTL Indexes是一个特殊的索引，能够在一定时间之后将文档数据删除。主要用于存储时间，日志，session等数据

- Hidden Indexes: 该索引是一个特殊的索引，该索引不会被查询计划使用，并不能提升查询的性能。主要适用于逻辑删除索引，除了`_id`主键索引外，其他索引都可以使用。

## 2. 单字段索引

mongodb对于单字段有比较全的类型支持，在所有的结合中，都会有一个`_id`字段的主索引，用户可以自定义索引以支持不同的操作和查询。

![](../../../assets/76c0c68a61433858fc02225534c0c17fd7236a94.svg)

### 2.1 在单个字段上创建索引

这里还是以前面的inventory结果为例，则测试数据样例如下:

```shell
db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"], size: { h: 14, w: 21, uom: "cm" } },
   { item: "mat", qty: 85, tags: ["gray"], size: { h: 27.9, w: 35.5, uom: "cm" } },
   { item: "mousepad", qty: 25, tags: ["gel", "blue"], size: { h: 19, w: 22.85, uom: "cm" } }
])
```

通过以上数据，我们为`inventory`集合的`qty`创建一个升序的索引，则对应创建语句如下:

```shell
db.inventory.createIndex({qty: 1})
```

当索引创建成功后，则`qty`字段将支持索引查询，例如:

```shell
db.inventory.find({qty: 85})
db.inventory.find({qty: {$gt: 50}})
```

### 2.2 在嵌套文档属性上创建索引

在嵌套文档中，也可以在嵌套文档字段中创建索引，一样具有索引的功能。我们可以通过`.`的语义表达式为嵌套文档字段创建索引信息，具体定义如下:

```shell
db.inventory.createIndex({"size.h": 1})
```

则可以根据嵌套字段过滤数据:

```shell
 db.inventory.find({"size.h": 19})
 db.inventory.find({"size.h": 19, "size:w": 22.85})
```

### 2.3 在嵌套文档上创建索引

mongodb可以在整个嵌套文档上创建索引, 具体语法如下:

```shell
db.inventory.createIndex({size: 1})
```

则可以通过`size`字段查询文档数据信息，则对应查询语句为：

```shell
 db.inventory.find({"size.w": 19})
```

对于索引的命中可以通过`explain()`方法查询执行计划，索引的命中情况，则对应语句为:

```shell
 db.inventory.find({"size.w": 19}).explain()
```

## 3. 聚合索引

mongodb支持聚合索引，也就是一个索引结构上有多个文档字段，则组合索引的组成结构如下:

![](../../../assets/9cfe38bb928dbd720f83d1c79c2bfa519c971d91.svg)

### 3.1 创建组合索引

可以通过如下的语法创建组合索引:

```shell
db.collection.createIndex( { <field1>: <type>, <field2>: <type2>, ... } )
```

在以上的语法中，value描述了对应字段的索引类型。例如，当对应值为1的时候，表示索引按照升序排列。当值为-1的时候按照倒叙排列。在mongodb中索引的对应类型有很多中，可以查看对应的文档。

> 在热点索引上面，索引字段的顺序对于性能有很大的影响。这就跟mysql中左前缀索引类似。

> 从4.4版本开始：
> 
> - 组合索引字段中可能包含了hash索引的字段
> 
> - 当创建聚合索引的时候，如果多个字段都是hash索引时，将会报错
> 
> 在4.2版本之前：
> 
> - 组合索引中可能不会包含hash索引的字段
> 
> - 在创建组合索引的时候，如果组合索引字段中包含了hash索引，则会报错

例如，以官方文档中的例子实现:

```shell
db.products.insertMany([
  {
 "item": "Banana",
 "category": ["food", "produce", "grocery"],
 "location": "4th Street Store",
 "stock": 4,
 "type": "cases"
},
{
 "item": "apple",
 "category": ["food", "produce"],
 "location": "2th Street Store",
 "stock": 20,
 "type": "cases"
}
])
```

插入两个产品信息到集合中，在item和stock上创建一个组合索引，字段均是正序排列，则对应的创建语句为:

```shell
db.products.createIndex( { "item": 1, "stock": 1 } )
```

则使用组合索引查询文档数据，查询语句为：

```shell
db.products.find( { item: "Banana" } )
db.products.find( { item: "Banana", stock: { $gt: 5 } } )
```

### 3.2 排序

针对单个字段的索引来说，字段的排序其实并不会有太大的影响，因为mongodb可以通过遍历key实现。但是组合索引就会比较大的影响，聚合索引的顺序会影响查询和排序操作是否生效。

假设events集合中有`username`和`date`的字段，我们可以通过查询结果，按照`username`升序和`date`降序返回，则对应的查询为：

```shell
db.events.find().sort( { username: 1, date: -1 } )
```

或者events集合按照username倒序和date升序返回结果集, 则对应的查询结果为:

```shell
db.events.find().sort( { username: -1, date: 1 } )
```

以上情况，都可以通过创建索引实现，则对应的索引为:

```shell
db.events.createIndex( { "username" : 1, "date" : -1 } )
```

但是索引却不能实现按照`username`升序和`date`升序排列，也即:

```shell
db.events.find().sort( { username: 1, date: 1 } )
```

### 3.3 左前缀索引

左前缀索引是指查询的字段为索引字段列表的开始子集，例如有如下索引的定义：

```shell
{ "item": 1, "location": 1, "stock": 1 }
```

则左前缀索引包含了一下的情况

- `{ item: 1 }`

- `{ item: 1, location: 1 }`

在查询的时候，可以通过左前缀所以来提升查询的效率。只是左前缀索引效率并没有全匹配的索引效率高。也即可以通过`item`和`location`过滤文档数据，一样的可以使用到索引。

如果查询的过程中，跳过了某个中间的字段，如`item`和`stock`进行查询，这个时候并不能命中`stock`索引，而只能使用`item`索引进行查询和过滤。

在以下的查询中，将会导致索引失效，例如

- 使用location查询

- 使用stock查询

- 使用location和stock查询

## 4. MultiKey 索引

当文档字段为数组值时，mongodb为数组中的每个元素创建一个索引，MultiKey所以支持标量数组(例如字符串，数字)和嵌套文档。所以对应的组织结构图为：

![](../../../assets/a8f11f16f4927a7a46706da034d035be9a4d2cbd.svg)

### 4.1 创建MultiKey索引

可以通过`db.collection.createIndex()`方法创建索引，则对应的创建语法为：

```shell
db.coll.createIndex( { <field>: < 1 or -1 > } )
```

当创建的字段类型为数组时，则自动创建multikey所以，在创建的时候，无需显式的指定索引类型。

> 从3.4版本开始，Multikey 索引只针对于WiredTiger和Memory存储引擎。

### 4.2 索引边界

如果一个索引为Multikey类型，则索引的边界结算会遵循一定的规则。

### 4.3 唯一Multikey索引

对于唯一索引，唯一性约束是对整个集合生效，而不是单个文档。

因为唯一性约束适用于每个文档，因此，当文档中字段为数组类型时，此时该数组中的字段值不能和其他文档的字段值重复。

### 4.4 限制

#### 4.4.1 组合Multikey索引

在mongodb中，组合multikey索引具有一定的限制性，一个集合中，最多只能有一个被索引的字段为数组类型。

- 当多个字段类型为数组时，不能够创建multikey索引。例如有一下文档数据:
  
  ```json
  { _id: 1, a: [ 1, 2 ], b: [ 1, 2 ], category: "AB - both arrays" }
  ```
  
  则不能直接在{a:1, b:1}上创建multikey索引，这个会引起创建索引的错误。

- 当集合中存在了一个组合文档，在插入文档的时候，不能插入打破限制的文档数据。
  
  例如集合中包含了一下文档数据信息：
  
  ```json
  { _id: 1, a: [1, 2], b: 1, category: "A array" }
  { _id: 2, a: 1, b: [1, 2], category: "B array" }
  ```
  
  我们可以创建{a:1, b:1}的multikey索引，因为符合了在multikey中只能有一个字段为数组类型的限制。当我们将索引创建好了之后，再想文档中插入`a和b`均为数组的文档时，将会抛出异常，插入数据失败。

- 当字段的类型为数组时，我们可以为嵌套文档的字段加上索引信息，例如集合中有以下文档信息
  
  ```json
  { _id: 1, a: [ { x: 5, z: [ 1, 2 ] }, { z: [ 1, 2 ] } ] }
  { _id: 2, a: [ { x: 5 }, { z: 4 } ] }
  ```
  
  则可以创建索引`{ "a.x": 1, "a.z": 1 }`, 该multikey索引也是符合只有一个字段为数组类型的约定。

#### 4.4.2 排序

在mongodb4.4版本中，排序的行为有所改变。当在multikey 索引数组字段上排序时，在查询计划中包含了一个`blocking sort`的阶段，一下情况除外:

- 所有字段的排序边界为[minKey, maxKey]

- 并且任何multikey索引字段的边界都没有与排序模式相同的路径前缀

#### 4.4.3 分片key(shard key)

在mongodb中不能指定multikey的索引作为分片key.但是，当分片key是组合索引的前缀，在其他的key不是数组的时候（即不属于分片key的key），组合索引能够成为组合multikey索引。组合multikey索引对性能会有一定的影响。

#### 4.4.4 Hash索引

hash索引不能成multikey

#### 4.4.5 数组字段整体查询

当在文档字段数组上执行精确查询的时候，mongodb中可以使用multikey索引过滤数组，过滤规则为按照数组的第一个元素过滤，然后在精确的匹配每个元素。

例如，有集合inventory, 并包含有一下数据:

```json
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ] }
{ _id: 6, type: "food", item: "bbb", ratings: [ 5, 9 ] }
{ _id: 7, type: "food", item: "ccc", ratings: [ 9, 5, 8 ] }
{ _id: 8, type: "food", item: "ddd", ratings: [ 9, 5 ] }
{ _id: 9, type: "food", item: "eee", ratings: [ 5, 9, 5 ] }
```

在rating字段上创建索引，

```shell
db.inventory.createIndex( { ratings: 1 } )
```

执行一下查询，过滤文档字段rating的值为`[5,9]`的文档数据，则对应查询为:

```shell
db.inventory.find( { ratings: [ 5, 9 ] } )
```

则mongodb的执行过程为,

- 先过滤ratings的值为5的文档数据

- 然后从过滤的文档数据在匹配ratings值为9的文档

#### 4.4.6 $expr

语法`$expr`不支持multikey索引

### 4.5 边界

索引扫描的边界定义了查询期间要搜索的索引部分，当在索引上存在多个操作的时候，此时Mongodb将通过交叉或复合来组合这些操作，以便生成范围较小的扫描。

#### 4.5.1 相交边界

相交边界指代的是多个边界的与链接。例如有边界[3, Infinity]和[-Infinity, 6], 则两个边界相交的结果为[3,6]

例如有以下示例，在survey集合中包含了以下文档数据，则对应的文档为:

```json
{ _id: 1, item: "ABC", ratings: [ 2, 9 ] }
{ _id: 2, item: "XYZ", ratings: [ 4, 3 ] }
```

在ratings上创建multikey索引：

```shell
db.survey.createIndex( { ratings: 1 } )
```

在查询中，通过`$elemMatch`执行多个操作，同时满足多个条件:

```shell
db.survey.find( { ratings : { $elemMatch: { $gte: 3, $lte: 6 } } } )
```

因为操作是通过`$elemMatch`集成多个操作，因此mongodb能够相交两个查询的边界，则最终的执行结果为:

```json
{ratings: [3,6]}
```

但是在下面的查询中，因为没有使用`$elemMatch`的操作，将不会合并边界，

```shell
db.survey.find( { ratings : { $gte: 3, $lte: 6 } } )
```

在mongodb执行查询的时候，`ratings`数组中的元素至少有一个元素大于或者等于3并且至少一个元素小于或者等于6，因为单个元素不需要同时满足两个条件，因此mongodb并不会合并两个条件边界。

#### 4.5.2 数组字段组合索引

向集合servey中插入以下文档，

```shell
db.survey.insertMany([
{ _id: 1, item: "ABC", ratings: [ 2, 9 ] },
{ _id: 2, item: "XYZ", ratings: [ 4, 3 ] }
])
```

在`item`和`ratings`字段上创建组合索引。

```shell
db.survey.createIndex( { item: 1, ratings: 1 } )
```

在一下查询中，同时使用了两个key进行查询:

```shell
db.survey.find( { item: "XYZ", ratings: { $gte: 3 } } )
```

单独来看这两个查询条件：

- 在`item:XYZ`的查询边界为：`[XYZ, XYZ]`

- 查询`ratings: {$gte: 3}`的边界为`[3, Infinity]`

Mongodb能够组合这两个查询的边界，则组合和的边界信息为：

```json
{ item: [ [ "XYZ", "XYZ" ] ], ratings: [ [ 3, Infinity ] ] }
```

#### 4.5.3 在嵌套文档上创建索引

当文档的字段类型为数组，并且数组中存储的为文档内容时，可以通过在嵌套文档上创建索引。在创建索引的时候，可以通过`.`的语法表达式创建索引。

例如给定文档内容数据如下

```json
ratings: [ { score: 2, by: "mn" }, { score: 9, by: "anon" } ]
```

`.`的表达式的格式为: `ratings.score`

##### 4.5.3.1 费数组字段和数组字段的组合边界

假设存在集合`survey2`，并包含有如下字段信息:

```json
{
  _id: 1,
  item: "ABC",
  ratings: [ { score: 2, by: "mn" }, { score: 9, by: "anon" } ]
}
{
  _id: 2,
  item: "XYZ",
  ratings: [ { score: 5, by: "anon" }, { score: 7, by: "wv" } ]
}
```

创建一个非数组字段和两个嵌套文档中的字段信息，如下:

```shell
db.survey2.createIndex( { "item": 1, "ratings.score": 1, "ratings.by": 1 } )
```

查询指定所有的索引字段，对应查询为：

```shell
db.survey2.find( { item: "XYZ",  "ratings.score": { $lte: 5 }, "ratings.by": "anon" } )
```

分开来看对应的边界信息:

- 查询`item:XYZ`对应的边界信息为: `[XYZ, XYZ]`

- 查询`ratings.score:{$lte: 5}`的边界为`[-Infinity, 5]`

- 查询`ratings.by:anon`的查询边界为: `[anon, anon]`

在真正执行查询的过程中，可能会组合索引的边界信息为:

```json
{
  "item" : [ [ "XYZ", "XYZ" ] ],
  "ratings.score" : [ [ -Infinity, 5 ] ],
  "ratings.by" : [ [ MinKey, MaxKey ] ]
}
```

或者使用`item`和`ratings.by`作为组合索引，则最终优化结果为:

```json
{
  "item" : [ [ "XYZ", "XYZ" ] ],
  "ratings.score" : [ [ MinKey, MaxKey ] ],
  "ratings.by" : [ [ "anon", "anon" ] ]
}
```

> 这里如果要将`ratings.score`的边界与`ratings.by`的边界复合，就必须要使用`$elemMatch`进行操作，则查询条件可以变更为如下:

```shell
db.survey2.find( { item: "XYZ",ratings:{$elemMatch: {"score": { $lte: 5 }, "by": "anon" }}})
```

在以上执行的过程中，可以通过`explain()`方法查看mongodb的执行计划信息，查看两者的区别。

### 4.6 全文索引

mongodb提供了全文索引来对文本内容的过滤查询。全文索引能够支持字段为字符串类型或者数组中是文本的数组。

#### 4.6.1 版本

| 全文索引版本   | 描述信息                                     |
| -------- | ---------------------------------------- |
| Version3 | 在Mongodb 3.2及以后版本中，全文索引默认版本号为Version3    |
| Version2 | 该索引版本是从2.6版本引入，在2.6和3.0系列版本中，作为默认的全文索引版本 |
| Version1 | 该版本从2.4版本引入，在2.4版本中只支持Version1版本的全文索引    |

> 为了能够使用全文索引的不同版本，则需要在创建索引的时候，加入可选参数`{ "textIndexVersion": <version> }`

#### 4.6.2 创建全文索引

> 在mongodb中，一个结合最多只能有一个全文索引。
> 
> 但是在Mongo Altas中，一个集合能够支持多个全文索引。

在创建全文索引时，主要还是使用`db.collection.createIndex()`方法，只是在创建索引的时候，需要指定索引的类型为`text`类型，例如:

```shell
db.reviews.createIndex( { comments: "text" } )
```

在创建索引的时候，可以为多个字段指定全文索引，例如以下所以指定了comments和subject为全文索引信息

```shell
db.reviews.createIndex(
   {
     subject: "text",
     comments: "text"
   }
 )
```

在全文索引组合中，可以为索引指定升序或者降序实现。

#### 4.6.3 索引权重

索引字段的权重决定了相对于其他字段在文本搜索时的权重分数。对于文档中的每个索引字段，Mongodb将匹配数乘以权重，并对结果求和。使用这个求和数，就能够计算出文档的得分。

创建索引时，字段的默认权重为1，当我们需要修改字段的权重时候，可以指定weights可选参数。

#### 4.6.4 通配符全文索引(Wildcard)

> 通配符全文所以和通配符索引有着一定的区别，通配符索引(Wildcard Index)并不支持`$text`操作。

当在多个字段上创建全文索引的时候，可以通过通配符`$**`为文档中是文本类型的字段都建立上索引，则具体创建索引的方法为:

```shell
db.collection.createIndex( { "$**": "text" } )
```

通配符的全文索引也可以是组合索引的一部分，例如以下创建了一个组合索引，

```shell
db.collection.createIndex( { a: 1, "$**": "text" } )
```

该所以创建了，为了能够使用上全文索引，则`a`的查询条件必须是等值查询实现。

#### 4.6.5 大小写不敏感

在Version3中的全文索引中，是大消息不敏感了，在较早版本的全文索引中，只针对`[A-z]`的大小写不敏感。

#### 4.6.6 标记分隔符

在version3中的全文索引中，支持以下几种分隔符: `Dash`, `Hyphen`, `Pattern_Syntax`, `Quotation_Mark`, `Terminal_Punctuation`, 和`White_Space`

例如在给定一个字符串`Il a dit qu'il «était le meilleur joueur du monde»`,将使用`«`、`»`和空格作为分隔符。

在较早版本中，`«`、`»`不作为分隔符，而是和其他的字符一起处理使用。

#### 4.6.7 索引项

全文索引在建立索引项时，都需要对被做引的文字进行分词处理，然后将分词进行单独的存储。索引和文档都是分开存储，对于每一个分词都是单独进行组织，然后引用到对应的文档全部内容。

### 4.7 通配符索引

mongodb可以支持在一个字段和多个字段上面创建索引。在4.2版本之后，mongodb支持对任意位置字段的查询。

考虑有如下文档数据

```json
{ "userMetadata" : { "likes" : [ "dogs", "cats" ] } }
{ "userMetadata" : { "dislikes" : "pickles" } }
{ "userMetadata" : { "age" : 45 } }
{ "userMetadata" : "inactive" }
```

当希望能够在`userMetadata`上加入所以以支持在任何字段上进行查询时，就可以使用通配符索引来实现。将通配符索引加到`userMetadata`字段上时，就能够支持单字段的查询，包括`userMetadata`, `userMetadata.likes`、`userMetadata.dislikes`、`userMetadata.age`。则对应的通配符创建方式为：

```shell
db.userData.createIndex( { "userMetadata.$**" : 1 } )
```

则索引能够支持以下查询:

```shell
db.userData.find({ "userMetadata.likes" : "dogs" })
db.userData.find({ "userMetadata.dislikes" : "pickles" })
db.userData.find({ "userMetadata.age" : { $gt : 30 } })
db.userData.find({ "userMetadata" : "inactive" })
```

> 如果在userMetadata上创建的是一个普通的索引，则只能够对userMetadata上的值进行查询并使用索引。

#### 4.6.1 创建通配符索引

##### 4.6.1.1 在单个字段上创建索引

对指定字段创建通配符索引的语句为:

```shell
db.collection.createIndex( { "fieldA.$**" : 1 } )
```

这种类型的通配符索引，mongodb将`fieldA`字段的所有值都建立索引。如果字段的值为嵌套文档或者数组，建立索引时将遍历数组或者嵌套文档的所有属性，然后喂所有属性建立索引信息。

例如在集合`product_catalog`中包含有一下文档数据信息:

```json
{
  "product_name" : "Spy Coat",
  "product_attributes" : {
    "material" : [ "Tweed", "Wool", "Leather" ]
    "size" : {
      "length" : 72,
      "units" : "inches"
    }
  }
}

{
  "product_name" : "Spy Pen",
  "product_attributes" : {
     "colors" : [ "Blue", "Black" ],
     "secret_feature" : {
       "name" : "laser",
       "power" : "1000",
       "units" : "watts",
     }
  }
}
```

则可以通过一下方式在`product_attributes`字段上创建通配符索引:

```shell
db.products_catalog.createIndex( { "product_attributes.$**" : 1 } )
```

则以上索引信息能够支持以下方式查询数据:

```shell
db.products_catalog.find( { "product_attributes.size.length" : { $gt : 60 } } )
db.products_catalog.find( { "product_attributes.material" : "Leather" } )
db.products_catalog.find( { "product_attributes.secret_feature.name" : "laser" } )
```

##### 4.6.1.2 在所有字段上创建索引

为了能够给文档中的所有字段创建建立索引，可以使用`$**`通配符实现，则创建索引方式为:

```shell
db.collection.createIndex( { "$**" : 1 } )
```

这个索引会为文档中的每个字段建立索引，如果字段类型为嵌套文档或者数组类型，会遍历创建索引。

##### 4.6.1.3 指定多字段建立索引

可以通过`wildcardProjection`设置需要通配的字段列表，例如:

```shell
db.collection.createIndex(
  { "$**" : 1 },
  { "wildcardProjection" :
    { "fieldA" : 1, "fieldB.fieldC" : 1 }
  }
)
```

在这个索引中, mongodb为指定的字段创建索引，当指定的字段为嵌套文档或者数组的时候，则遍历为嵌套文档所有字段和数组元素建立索引。

> 当使用wildcardProjection创建通配符索引的时候，不能混合排除/排除某个字段，`_id`字段除外。

##### 4.6.1.4 显式排除字段

在创建通配符索引的时候，可以显式的指定字段不建立所以，对应的创建方式为:

```shell
db.collection.createIndex(
  { "$**" : 1 },
  { "wildcardProjection" :
    { "fieldA" : 0, "fieldB.fieldC" : 0 }
  }
)
```

也就是配合wildcardProjection使用，并配合1和0使用。

#### 4.6.2 注意事项

- 通配符索引最多支持一个字段的任何查询操作

- 通配符索引默认省略了`_id`字段，如果需要包含`_id`字段信息，则需要显式的指定`{_id: 1}`为`_id`字段建立索引

- 在一个集合中能够建立多个通配符索引

- 在集合中，通配符索引的字段可以也建立了其他类型的索引类型

- 通配符索引为稀疏索引，索引紧紧包含了索引字段的内容，尽管索引字段可能包含了一个null值

#### 4.6.3 行为

通配符索引如果索引字段为对象或者数组时，具有一些特定的行为:

- 当通配符索引遇到字段类型为对象时，将会进入到对象，为对象每个字段建立索引。并为其后遇到的每个对象的字段建立索引

- 如果索引的字段是一个数组类型，则为数组中的每个元素建立索引:
  
  - 如果数组的元素为对象，将会为对象的每个字段建立索引
  
  - 如果数组中的值依然为数组，此时将不会再遍历数组，而是将数组的值作为一个整体建立索引

- 对于其他标量类型的值，则直接将标量的值作为索引

假如集合中包含了以下文档内容:

```json
{
  "parentField" : {
    "nestedField" : "nestedValue",
    "nestedObject" : {
      "deeplyNestedField" : "deeplyNestedValue"
    },
    "nestedArray" : [
      "nestedArrayElementOne",
      [ "nestedArrayElementTwo" ]
    ]
  }
}
```

当尝试在`parentField`上建立通配符索引的时候，在索引记录上将包含一下信息:

- `"parentField.nestedField" : "nestedValue"`

- `"parentField.nestedObject.deeplyNestedField" : "deeplyNestedValue"`

- `"parentField.nestedArray" : "nestedArrayElementOne"`

- `"parentField.nestedArray" : ["nestedArrayElementTwo"]`

尤其注意`parentField.nestedArray`并不包含数组中其他元素的信息，而是将数组作为整体存储。

#### 4.6.4 限制

通配符索引也存在一定的限制：

- 不能使用通配符索引做数据的分片,如果需要做数据的分片，则需要单独创建索引

- 不能创建组合索引

- 创建通配符索引时不能指定以下参数：
  
  - TTL
  
  - Unique

- 不能通过通配符的方式创建以下索引:
  
  - 2d
  
  - 2dsphere
  
  - hashed

#### 4.6.5 查询和排序的支持

##### 4.6.5.1 覆盖查询

只有再以下条件满足的时候，通配符索引能够覆盖查询：

- 针对查询动作，查询计划选择通配符索引

- 查询动作只针对通配符索引覆盖的字段

- 查询projection中显示的排除了`_id`字段，指包括查询字段

- 指定查询的字段不是一个数组

假设在products集合上有以下通配符索引:

```shell
db.products.createIndex( { "$**" : 1 } )
```

通过以下方式过滤文档数据

```shell
db.products.find(
  { "lastName" : "Doe" },
  { "_id" : 0, "lastName" : 1 }
)
```

假设`lastName`不是为数组类型，则可以使用通配符索引支持覆盖查询。

##### 4.6.5.2 多字段查询

通配符索引最多支持一个字段的查询动作:

- Mongodb不能使用非通配符索引过滤部分文档数据，再使用通配符索引过滤剩下的数据

- 不能使用通配符索引过滤部分文档数据，再使用通配符索引过滤剩下的文档数据

- 通配符索引只能支持一个字段的查询，剩下的字段数据过滤是没有索引

> 但是通配符索引能够支持单个查询操作，比如使用`$or`查询

##### 4.6.5.3 查询排序

Mongodb只有在满足一下条件的时候，才能够使用通配符索引进行排序：

- 针对查询操作，查询计划器使用通配符索引执行数据过滤

- 按照查询的字段进行排序

- 指定的字段不是数组类型

以上条件不满足时，mongodb将不会使用通配符索引进行排序。

假如在products集合中创建如下通配符索引：

```shell
db.products.createIndex( { "product_attributes.$**" : 1 } )
```

有如下操作：

```shell
db.products.find(
  { "product_attributes.price" : { $gt : 10.00 } },
).sort(
  { "product_attributes.price" : 1 }
)
```

加入`price`不是为数组类型，则可以使用price进行排序。

##### 4.6.5.4 不支持的查询操作

- 通配符索引不支持判断字段是否存在

- 通配符索引不能支持判断一个字段的值是否等于文档或者数组

- 通配符索引不能支持判断一个字段的值是否为null

##### 4.6.5.5 显示数组查询

通配符索引在建立索引期间不会建立数组元素的位置信息。然而，仍然可以通过通配符索引来查询显示数组的查询。例如`parentArray.0.nestedArray.0`. 但是当显示查询数组的数量查过8个的时候，mongodb将不会使用通配符索引查询文档数据。
