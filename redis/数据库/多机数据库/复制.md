# 复制
在Redis中, 用户可以通过执行`SLAVEOF`命令或者设置`slaveof`选项, 让一个服务器去复制另一个服务器
- 被赋值的服务器叫做主服务器
- 对主服务器进行赋值的服务器则被称为从服务器

进行负值中的主从服务器双方的数据库将保存相同的数据， 概念上将这种现象称作"数据库状态一致", 或者简称"一致"

## 旧版复制功能的实现
旧版功能主要是指`Redis 2.8`以前版本, 在复制的时候会出现一些低效的情况

Redis的复制功能分为`同步(sync)`和`命令传播(command propagate)`两个操作:
- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
- 命令传播操作则用于在主服务器的数据库状态被修改, 导致从服务器的数据库状态出现不一致时, 让主服务器的数据库重回到一致状态。

### 同步
当客户端想服务器发送SALVEOF命令, 要求从服务器复制主服务器时, 从服务器首先需要执行同步操作, 也即是, 将从服务器状态更新至主服务器当前所处的数据库状态。

从服务器对主服务器的同步操作需要通过向主服务器发送`SYNC`命令来完成,以下是`SYNC`命令的执行步骤：
- 从服务器向主服务器发送`SYNC`命令
- 收到SYNC命令的主服务器执行BGSAVE命令, 在后台生成一个RDB文件, 并使用一个缓冲区记录从现在开始执行的所有命令
- 当主服务器的`BGSAVE`命令执行完毕时, 主服务器将`BGSAVE`命令生成的RDB文件发送给从服务器, 从服务器接收并载入这个RDB文件, 将自己的数据状态更新至主服务器执行BGSAVE命令时的数据库状态
- 主服务器将记录在缓冲区里面的所有鞋命令发送给从服务器, 从服务器执行这些写命令, 将自己的数据库状态更新至主服务器数据库当前所处的状态。

### 命令传播
在同步操作执行完毕之后, 主从服务器两者的数据库将达到一致状态, 但这种一致并不是一成不变的, 每当主服务器执行客户端发送的写命令时, 主服务器的数据库就有可能会被修改,并导致主从服务器状态不一致.

为了让主从服务器再次回到一致状态, 主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令, 也即是造成主从服务器不一致的那条写命令, 发送给从服务器执行, 当从服务器执行了相同的写命令之后, 主从服务器将再次回到一致状态。

## 旧版复制功能的缺陷
- 初次复制: 从服务器以前没有复制过任何主服务器, 或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。
- 断线后重复制: 处于命令传播阶段的主从服务器因为网络原因而中断了复制, 但从服务器通过自动重链接重新连上了主服务器, 并继续复制主服务器。

> NOTE: 对于断线后重复制来说, 旧版复制功能虽然也能让主服务器重新回到一致状态, 但效率却非常低

### SYNC命令时一个非常消耗资源的操作
- 主服务器需要执行`BGSAVE`命令来生成RDB文件, 这个生成操作会耗费主服务器大量的CPU, 内存和磁盘I/O资源
- 主服务器需要将自己生成的RDB文件发送给从服务器, 这个发送操作会耗费主从服务器大量的网络资源, 并对主服务器响应命令请求的时间产生影响。
- 接收到RDB文件的从服务器需要载入主服务器发来的RDB文件, 并且在载入期间, 从服务器因为阻塞而没办法处理命令请求。

## 新版赋值功能的实现
为了解决旧版赋值功能在处理断线重复制情况时的低效问题, Redis从`2.8`开始使用`PSYNC`命令代替`SYNC`命令来执行复制时的同步操作.

`PSYNC`命令具有`完整同步`和`部门重同步`两种模式:
- 其中完整同步用于处理初次复制情况: 完整重同步的执行步骤和SYNC命令的执行步骤基本一致, 他们都是通过让主服务器创建并发送RDB文件, 以及向从服务器发送保存在缓存区里面的写命令来进行同步。
- 而部分同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时, 如果条件允许, 主服务器可以将主从服务器断开期间执行的写命令发送给从服务器, 从服务器只要接受并执行这些命令，就可以将数据库更新至主服务器当前所处的状态。

## 部分重同步的实现
部分重同步功能由一下三个部分构成:
- 主服务器的赋值偏移量(replication offset)和从服务器的赋值偏移量
- 主服务器的赋值积压缓冲区(replication backlog)
- 服务器的运行ID(run ID)


### 复制偏移量
执行复制的双方——主服务器和从服务器会分别维护一个赋值偏移量
- 主服务器每次向从服务器传播N个字节的数据时, 就将自己的服务制偏移量的值加上N
- 从服务器每次收到主服务器传播来的N个字节的数据时, 就将自己的服务制偏移量的值加上N

通过主从服务器的复制偏移量, 程序可以很容易地知道主从服务器是否处于一致状态:
- 如果主从服务器处于一致状态, 那么主从服务器两者的偏移量总是相同的
- 相反, 如果主从服务器两者的偏移量并不相同, 那么说明主从服务器并未处于一致状态。

### 复制挤压缓冲区
复制积压缓冲区是由主服务器维护的一个固定长度先进先出(FIFO)队列, 默认大小为`1MB`

当主服务器进行命令传播时, 它不仅会将写命令发送给所有从服务器, 还会将写命令入队到复制积压缓冲区里面.
因此, 主服务器的复制积压缓冲区里面保存着一部分最近传播的写命令, 并且复制积压缓冲区为队列中的每个字节记录响应的复制偏移量。

当从服务器重新连上主服务器时, 从服务器会通过`PSYNC`命令将自己的复制偏移量`offset`发送给主服务器, 主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作:
- 如果offset偏移量之后的数据(也即是偏移量offset + 1开始的数据)仍然存在于复制积压缓冲区里面, 那么主服务器将对从服务器执行部分重同步操作
- 相反, 如果offset偏移量之后的数据已经不存在与复制积压缓冲区, 那么主服务器将对从服务器执行完整重同步操作。

#### 根据需要调整复制积压缓冲区的大小
Redis为复制积压缓冲区设置的默认大小为`1MB`, 如果主服务器需要执行大量写命令, 又或者从服务器断线后重连所需要的时间比较长, 那么这个大小也许并不合适.

复制积压缓冲区的最小大小可以根据公式: `second * write_size_per_second`
- 其中`second`为从服务器断线后重新连接上主服务器所需要的平均时间
- 而`write_size_per_second`则是主服务器平均每秒产生的写命令数据量(协议格式的写命令的长度总和)

为了安全起见, 可以将复制积压缓冲区的大小设为`2 * second * write_size_per_second`, 这样可以保证绝大部分断线情况都能用部分重同步来处理.具体修改, 可以参考配置:`repl-backlog-size`

### 服务器的运行ID
除了复制偏移量和复制积压缓冲区之外, 实现部分重同步还需要用到服务器运行 `ID`:
- 每个redis服务器, 不论主服务器还是从服务器，都会有自己的运行ID
- 运行ID在服务器启动时自动生成, 由40个随机的十六进制字符组成。

当从服务器对主服务器进行初次复制时, 主服务器会将自己的运行ID传送给从服务器, 而从服务器则会将这个运行ID保存起来。

当从服务器断线并重新连上一个主服务器时, 从服务器将当前连接的主服务器发送之前保存的运行ID:
- 如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同, 那么说明从服务器断线之前赋值的就是当前连接的这个主服务器, 主服务器可以继续尝试执行部分重同步操作。
- 相反地, 如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同, 那么说明从服务器断线之前赋值的主服务器并不是当前连接的这个服务器, 主服务器将对这个从服务器执行完整重同步操作。

## PSYNC 命令的实现
PSYNC命令的调用有两种:
- 如果从服务器以前没有复制过任何主服务器, 或者之前执行过`SLAVEOF no one`命令, 那么从服务器现在开始一次新的复制时将想主服务器发送`PSYNC ? -1`命令, 主动请求主服务器进行完整重同步。
- 相反地, 如果从服务器已经赋值过某个主服务器, 那么从服务器在开始一次新的复制时将主动发送`PSYNC <runid> <offset>`. 接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。

根据情况, 接收到`PSYNC`命令的主服务器会向从服务器返回以下三种回复的其中一种:
- 如果主服务器返回 `+FULLRESYNC <runid> <offset>`回复, 那么表示主服务将于从服务器执行完整重同步操作.
- 如果主服务器返回`+CONTINUE`回复, 那么表示主服务器将与从服务器执行部分重同步操作, 从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了
- 如果主服务器返回`-ERR`回复, 那么表示主服务器的版本低于`REDIS 2.8`, 它识别不了`PSYNC`命令，从服务器将向主服务发送`SYNC`命令，并与主服务器执行完整同步流程。

## 复制的实现
通过向从服务器发送`SLAVEOF`命令, 我们让一个从服务器去复制一个主服务器.
```sh
SLAVEOF <master_ip> <master_port>
```
### 步骤1: 设置主服务器的地址和端口
从服务器首先要做的就是将客户端给定的主服务器IP地址`127.0.0.1`以及端口`6379`保存到服务器状态的`masterhost`属性和`masterport`属性里面:
```c
struct redisServer {
  // 主服务器的地址
  char *masterhost;

  // 主服务器的端口
  int masterport;
}
```
`SLAVEOF`命令是一个异步命令, 在完成`masterhost`属性和`masterport`属性的设置工作之后, 从服务器将向发送`SLAVEOF`命令的端口返回`OK`. 表示复制命令已经被接收, 而实际的复制工作将在`OK`返回之后才正真开始执行。

### 步骤2: 建立套接字链接
在`SLAVEOF`命令执行之后, 从服务器将根据命令所设置的IP地址和端口, 创建连向主服务器的套接字连接。

如果从服务器创建按的套接字能成功连接到主服务器, 那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器, 这个处理器将负责执行后续的复制工作. 比如接收`RDB`文件, 以及接收主服务器传播来的写命令。

而主服务器在接受从服务器的套接字链接之后, 将为该套接字创建相应的客户端状态, 并将从服务器看做是一个连接到主服务器的客户端来对待。这时从服务器将同时具有服务器和客户端两个身份:
- 从服务器可以向主服务器发送请求命令
- 主服务器则会向从服务器返回命令回复。

### 步骤3：发送PING命令
从服务器成为主服务器的客户端之后, 做的第一件事就是想主服务器发送改一个`PING`命令
这个`PING`有两个作用:
  - 虽然从服务器成功建立起了套接字链接, 但双方并未使用该套接字进行过任何通信, 通过发送`PING`命令可以检查该套接字的读写状态是否正常
  - 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行, 通过发送`ping`命令可以检查主服务器是否正常处理命令请求。

从服务器在发送`PING`命令之后将遇到以下三种情况的其中一种:
- 如果主服务器想从服务器返回了一个命令回复， 但从服务器却不能在规定的实现内读取出命令回复的内容, 那么表示主从服务器之间网络状态不佳, 不能继续执行复制工作的后续步骤。当出现这种情况时, 从服务器断开并重新创建连向主服务器的套接字。
- 如果主服务器想从服务器返回一个错误, 那么表示主服务器这暂时没办法处理从服务器的命令请求, 不能继续执行复制工作的后续步骤。当出现这种情况时, 从服务器断开并重新创建连向主服务器的套接字.
- 如果从服务器读取到`PONG`回复, 那么表示主从服务器之间的网络连接状态正常, 并且主服务器可以正常处理从服务器发送的命令请求, 在这种情况下, 从服务器可以继续执行复制工作的下个步骤.

### 步骤4: 身份认证
从服务器在收到主服务器返回的"PONG"回复之后, 下一步要做的就是觉得是否进行身份验证:
- 如果从服务器设置了`masterauth`选项, 那么进行身份认证
- 如果从服务器没有设置`masterauth`选项, 那么不进行身份认证。

在需要进行身份验证的情况下, 从服务器将向主服务器发送一条`AUTH`命令, 命令参数为从服务器`masterauth`选项的值.

- 如果主服务器没有设置`requirepass`选项, 并且从服务器也米有设置`masterauth`选项, 那么主服务器将继续执行从服务器发送的命令, 复制工作可以继续进行。
- 如果从服务器通过`AUTH`命令发送的密码和主服务器`requirepass`选项所设置的密码相同, 那么主服务器将继续执行从服务器发送的命令, 复制工作可以继续进行。与此相反, 如果主从服务器设置的密码不相同, 那么主服务器将返回一个`invalid password`错误
- 如果主服务器设置了`requirepass`选项, 但从服务器却没有设置`masterauth`选项, 那么主服务器将返回一个`NOAUTH`错误。另一方面, 如果主服务器没有设置`requirepass`选项, 但从服务器却设置了`masterauth`选项, 那么主服务器将返回一个`no password is set`错误。

所有错误情况都会令从服务器终止目前的赋值工作, 并从创建套接字开始重新执行复制, 知道身份验证通过, 或者从服务器放弃执行复制为止。

### 步骤5: 发送端口信息
在身份验证步骤之后, 从服务器将执行命令`REPLCONF listening-part <port-number>`, 向主服务器发送从服务器的监听端口号. 主服务器在接收到这个命令之后, 会将端口号记录在从服务器所对应的客户端状态的`slave_listening_port`属性中:
```c
typedef struct redisClient {
  // 从服务器的监听端口号
  int slave_listening_port;
}
```
`slave_listening_port`属性目前唯一的作用就是在主服务器执行`INFO replication`命令时打印出从服务器的端口号.

### 步骤6: 同步
在这一步, 从服务器将向主服务器发送`PSYNC`命令, 执行同步操作, 并将自己的数据库更新至主服务器数据库当前所处的状态。
值得一提的是, 在同步操作执行之前, 只有从服务器是主服务器的客户端, 但是在执行同步操作之后, `主服务器也会成为从服务器的客户端`:
- 如果`PSYNC`命令执行的是完整重同步操作, 那么主服务器需要成为从服务器的客户端, 才能将保存在缓冲区里面的写命令发送给从服务器执行.
- 如果`PSYNC`命令执行的是部分重同步操作, 那么主服务器需要成为从服务器的客户端, 才能向从服务器发送保存在复制积压缓冲区里面的写命令。

> NOTE: 在同步操作执行之后, 主从服务器双方都是对方的客户端, 他们可以相互向对方发送命令请求, 或者相互向对象返回命令回复.

### 步骤7: 命令传播
当完成了同步之后, 主从服务器就会进入命令传播阶段, 这时主服务器只要将自己执行的写命令发送给从服务器, 从而服务器只要一直接受并执行主服务器发俩的写命令, 就可以保证主从服务器一直保持一致了。

## 心跳检测
在命令传播阶段, 从服务器默认会以`每秒一次`的频率, 向主服务器发送命令:
```sh
REPLCONF ACL <replication_offset>
```
其中`replication_offset`是从服务器当前的复制偏移量.

发送`REPLCONF ACK`命令对于主从服务器有三个作用:
- 检测主从服务器的网络连接状态
- 辅助实现`min-slaves`选项
- 检测命令丢失

### 检测主从服务器的网络连接状态
主从服务器可以通过发送和接收`REPLCONF ACK`命令来检查两者之间的网络是否正常: 如果主服务器超过`一秒钟`没有收到从服务器发来的`REPLCONF ACK`命令, 那么主服务器就知道主从服务器之间的链接出现问题。

通过向主服务器发送`INFO replication`命令, 在列出的从服务器的`lag`一栏中, 我们可以看到从服务器最后一次向主服务器发送`REPLCONF ACK` 命令距离现在过了多少秒;

在一般情况下, `lag`的值应该在0秒或者1秒之间跳动, 如果超过1秒, 那么说明主从服务器之间的链接出现了故障。

### 辅助实现`min-slaves`配置选项
Redis的`min-salves-to-write`和`min-slaves-max-lag`两个选项可以防止主服务器在不安全的情况下执行写命令.

```sh
min-slaves-to-write 3
min-slaves-max-lag 10
```
那么在从服务器的数量少于3个, 或者三个从服务器的延迟`lag`值都大于或等于10秒时, 主服务器将拒绝执行写命令。

### 检测命令丢失
如果因为网络故障, 主服务器传播给从服务器的写命令在半路丢失, 那么当从服务器向主服务器发送`REPLCONF ACK`命令时， 主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量, 然后主服务器就会根据从服务器提交的复制偏移量。在复制积压缓冲区里面找到从服务器缺少的数据,并将这些数据重新发送给从服务器。

#### 主从服务器缺失数据不发与部分重同步比较
- 补发确实数据在主从服务器没有断线的情况下执行
- 部分重同步操作则在主从服务器断线并重连之后执行。

> NOTE: `REPLCONF ACK`命令和复制积压缓冲区都是Redis 2.8版本新增的, 在Reids 2.8以前, 即使命令在传播过程中丢失, 主服务器和从服务器不会注意到, 主服务器更不会想从服务器不发丢失的数据, 所以为了保证复制时主从服务器的数据一致性, 最好使用2.8或以上版本的Redis.
