# 客户端
通过使用由I/O多路复用技术实现的文件事件处理器, Redis服务器使用`单线程单进程`的方式来处理命令请求, 并与多个客户端进行网络通信。

对于每个与服务器进行连接的客户端, 服务器都为这些客户端建立了响应的`redisClient`结构. 这个结构保存了客户端当前的状态信息, 以及执行相关功能时需要用到的数据结构
- 客户端的套接字描述符
- 客户端的名字
- 客户端的标志值(flag)
- 指向客户端正在使用的数据库的指针， 以及该数据库的号码
- 客户端当前要执行的命令, 命令的参数, 命令参数的个数, 以及指向该命令实现函数的指针
- 客户端的输入缓冲区和输出缓冲区
- 客户端的复制状态信息, 以及进行复制所需的数据结构
- 客户端执行BRPOP,`BLPOP`等列表阻塞命令时使用的数据结构
- 客户端事务状态, 以及执行`watch`命令时用到的数据结构
- 客户端执行发布与订阅功能时用到的数据结构
- 客户端的身份标志
- 客户端的创建时间, 客户端和客户端最后一次通信的时间, 以及客户端的输出缓冲区大小超出软性限制(soft limit)的时间。

## 客户端连接信息保存
在`redisServer`中保存了连接redis服务器的所有客户端列表`clients`. 该连接信息通过链表的方式进行保存.
```c
struct redisServer {
  // 一个链表, 保存了所有客户端状态
  list *clients;
}
```

## 客户端属性
- 一类是比较通用的属性, 这些属性很少于特定功能相关
- 一类是和特定功能相关的属性

### 客户端的套接字描述符
客户端状态的`fd`属性记录了客户端正在使用的套接字描述符:
```c
typedef struct redisClient {
  //
  int fd;
}
```

根据客户端类型的不同, `fd`属性的值可以是`-1`或者大于`-1`的整数
- 伪客户端(fake client)的fd属性的值为-1: 为客户端处理的命令请求来源于AOF文件或者lua脚本，而不是网络, 所以这种客户端不需要套接字链接, 自然也不需要记录套接字描述符.
  - 一个用于载入AOF文件还原数据库状态
  - 用于执行Lua脚本中包含的Redis命令
- 普通客户端的`fd`的属性的值大于`-1`的整数: 普通客户端使用套接字来与服务器进行通信, 所以服务器会用`fd`属性来记录客户端套接字的描述符。合法的套接字描述符不能是`-1`, 所以普通客户端的套接字描述符的值必然是大于`-1`的整数.

> NOTE: 可以通过`CLIENT LIST`查看客户端连接情况
### 名字
在默认情况下, 一个链接到服务器的客户端是没有名字的.

可以使用`CLIENT setname`命令可以为客户端设置一个名字, 让客户端的身份变得清晰。
客户端的名字记录在客户端状态的`name`属性里面：
```c
typedef struct redisClient {
  robj *name;
}
```
如果客户端没有为自己设置名字, 那么响应客户端状态的`name`属性指向`NULL`指针;相反地, 如果客户端为自己设置了名字, 那么`name`属性指向一个字符串对象。而该对象就保存着客户端的名字。

### 标志
客户端的标志属性`flags`记录了客户端的角色(role), 以及客户端目前所处的状态:
```c
typedef struct redisClient {
  int flags;
}
```

- `flags`属性的值可以是单个标志: `flags = <flag>`
- `flags`也可是多个标志的二进制: `flags = <flag1> | <flag2>`

- 在主从服务器进行复制操作时, 主服务器成为从服务器的客户端, 而从服务器也会成为主服务器的客户端.
  - `REDIS_MASTER`标志表示客户端代表的是一个主服务器
  - `REDIS_SLAVE`标志表示客户端代表的是一个从服务器
- `REDIS_PRE_PSYNC`标志表示客户端代表的是一个版本低于`Redis 2.8`的从服务器, 主服务器不能使用`PSYNC`命令与这个从服务器进行同步. 这个标志只能在`REDIS_SLAVE`标志处于打开状态时使用.
- `REDIS_LUA_CLIENT`标识标识客户端是专门处理Lua脚本里面包含的Redis命令的伪客户端
- `REDIS_MONITOR`标志表示客户端正在执行`MONITOR`命令
- `REDIS_UNIX_SOCKET`标志表示服务器使用UNIX套接字来链接客户端
- `REDIS_BLOCKED`标志表示客户端正在被`BRPOP`,`BLPOP`等命令阻塞
- `REDIS_UNBLOCKED`标志表示客户端已经从`REDIS_BLOCKED`标志表示的阻塞状态中脱离出来, 不在阻塞. 该标志只能在`REDIS_BLOCKED`标志已经打开的情况下使用。
- `REDIS_MULTI`标志表示客户端正在执行事务
- `REDIS_DIRTY_CAS`标志表示事务使用`WATCH`命令监视的数据库键已经被修改,`REDIS_DIRTY_EXEC`标志表示事务在命令入队时出现错误, 以上两个标志都表示事务的安全性已经被打破, 只要这两个标记中的任意一个被打开，`EXEC`命令必须会执行失败. 这两个标志只能在客户端打开了`REDIS_MULTI`标志的情况下使用.
- `REDIS_CLOSE_ASAP`标志表示客户端的输出缓冲区大小超出了服务器允许的范围, 服务器会在下一次执行`serverCron`函数时关闭这个客户端, 一面服务器的稳定受到这个客户端的影响。积存在输出缓冲区的所有内容会直接被释放, 不会返回给客户端。
- `REDIS_CLOSE_AFTER_REPLY`标示标示由用户对这个客户端执行了`CLIEN KILL`命令, 或者客户端发送给服务器的命令请求中包含了错误的协议内容。`服务器会将客户端积存在输出缓冲区的所有内容发送给客户端`，然后关闭客户端
- `REDIS_ASKING`标志客户端向集群节点发送了`ASKING`命令
- `REDIS_FORCE_AOF`标志强制服务器将当前执行的命令写入到AOF文件里面，`REDIS_FORCE_REPL`标志强制主服务器将当前执行的命令复制给所有从服务器。执行`PUTSUB`命令会使客户端打开`REDIS_FORCE_AOF`标志, 执行`SCRIPT LOAD`命令会使客户端打开`REDIS_FORCE_AOF`标志和`REDIS_FORCE_REPL`标志.
- 在主服务器进行命令传播期间, 从服务器需要向主服务器发送`REPLICATION ACK`命令, 在发送这个命令之前, 从服务器必须打开主服务器对应的客户端的`REDIS_MASTER_FORCE_REPLY`标志, 否则发送操作会被拒绝执行。
