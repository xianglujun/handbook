# 客户端
通过使用由I/O多路复用技术实现的文件事件处理器, Redis服务器使用`单线程单进程`的方式来处理命令请求, 并与多个客户端进行网络通信。

对于每个与服务器进行连接的客户端, 服务器都为这些客户端建立了响应的`redisClient`结构. 这个结构保存了客户端当前的状态信息, 以及执行相关功能时需要用到的数据结构
- 客户端的套接字描述符
- 客户端的名字
- 客户端的标志值(flag)
- 指向客户端正在使用的数据库的指针， 以及该数据库的号码
- 客户端当前要执行的命令, 命令的参数, 命令参数的个数, 以及指向该命令实现函数的指针
- 客户端的输入缓冲区和输出缓冲区
- 客户端的复制状态信息, 以及进行复制所需的数据结构
- 客户端执行BRPOP,`BLPOP`等列表阻塞命令时使用的数据结构
- 客户端事务状态, 以及执行`watch`命令时用到的数据结构
- 客户端执行发布与订阅功能时用到的数据结构
- 客户端的身份标志
- 客户端的创建时间, 客户端和客户端最后一次通信的时间, 以及客户端的输出缓冲区大小超出软性限制(soft limit)的时间。

## 客户端连接信息保存
在`redisServer`中保存了连接redis服务器的所有客户端列表`clients`. 该连接信息通过链表的方式进行保存.
```c
struct redisServer {
  // 一个链表, 保存了所有客户端状态
  list *clients;
}
```

## 客户端属性
- 一类是比较通用的属性, 这些属性很少于特定功能相关
- 一类是和特定功能相关的属性

### 客户端的套接字描述符
客户端状态的`fd`属性记录了客户端正在使用的套接字描述符:
```c
typedef struct redisClient {
  //
  int fd;
}
```

根据客户端类型的不同, `fd`属性的值可以是`-1`或者大于`-1`的整数
- 伪客户端(fake client)的fd属性的值为-1: 为客户端处理的命令请求来源于AOF文件或者lua脚本，而不是网络, 所以这种客户端不需要套接字链接, 自然也不需要记录套接字描述符.
  - 一个用于载入AOF文件还原数据库状态
  - 用于执行Lua脚本中包含的Redis命令
- 普通客户端的`fd`的属性的值大于`-1`的整数: 普通客户端使用套接字来与服务器进行通信, 所以服务器会用`fd`属性来记录客户端套接字的描述符。合法的套接字描述符不能是`-1`, 所以普通客户端的套接字描述符的值必然是大于`-1`的整数.

> NOTE: 可以通过`CLIENT LIST`查看客户端连接情况
### 名字
在默认情况下, 一个链接到服务器的客户端是没有名字的.

可以使用`CLIENT setname`命令可以为客户端设置一个名字, 让客户端的身份变得清晰。
客户端的名字记录在客户端状态的`name`属性里面：
```c
typedef struct redisClient {
  robj *name;
}
```
如果客户端没有为自己设置名字, 那么响应客户端状态的`name`属性指向`NULL`指针;相反地, 如果客户端为自己设置了名字, 那么`name`属性指向一个字符串对象。而该对象就保存着客户端的名字。

### 标志
客户端的标志属性`flags`记录了客户端的角色(role), 以及客户端目前所处的状态:
```c
typedef struct redisClient {
  int flags;
}
```

- `flags`属性的值可以是单个标志: `flags = <flag>`
- `flags`也可是多个标志的二进制: `flags = <flag1> | <flag2>`

- 在主从服务器进行复制操作时, 主服务器成为从服务器的客户端, 而从服务器也会成为主服务器的客户端.
  - `REDIS_MASTER`标志表示客户端代表的是一个主服务器
  - `REDIS_SLAVE`标志表示客户端代表的是一个从服务器
- `REDIS_PRE_PSYNC`标志表示客户端代表的是一个版本低于`Redis 2.8`的从服务器, 主服务器不能使用`PSYNC`命令与这个从服务器进行同步. 这个标志只能在`REDIS_SLAVE`标志处于打开状态时使用.
- `REDIS_LUA_CLIENT`标识标识客户端是专门处理Lua脚本里面包含的Redis命令的伪客户端
- `REDIS_MONITOR`标志表示客户端正在执行`MONITOR`命令
- `REDIS_UNIX_SOCKET`标志表示服务器使用UNIX套接字来链接客户端
- `REDIS_BLOCKED`标志表示客户端正在被`BRPOP`,`BLPOP`等命令阻塞
- `REDIS_UNBLOCKED`标志表示客户端已经从`REDIS_BLOCKED`标志表示的阻塞状态中脱离出来, 不在阻塞. 该标志只能在`REDIS_BLOCKED`标志已经打开的情况下使用。
- `REDIS_MULTI`标志表示客户端正在执行事务
- `REDIS_DIRTY_CAS`标志表示事务使用`WATCH`命令监视的数据库键已经被修改,`REDIS_DIRTY_EXEC`标志表示事务在命令入队时出现错误, 以上两个标志都表示事务的安全性已经被打破, 只要这两个标记中的任意一个被打开，`EXEC`命令必须会执行失败. 这两个标志只能在客户端打开了`REDIS_MULTI`标志的情况下使用.
- `REDIS_CLOSE_ASAP`标志表示客户端的输出缓冲区大小超出了服务器允许的范围, 服务器会在下一次执行`serverCron`函数时关闭这个客户端, 一面服务器的稳定受到这个客户端的影响。积存在输出缓冲区的所有内容会直接被释放, 不会返回给客户端。
- `REDIS_CLOSE_AFTER_REPLY`标示标示由用户对这个客户端执行了`CLIEN KILL`命令, 或者客户端发送给服务器的命令请求中包含了错误的协议内容。`服务器会将客户端积存在输出缓冲区的所有内容发送给客户端`，然后关闭客户端
- `REDIS_ASKING`标志客户端向集群节点发送了`ASKING`命令
- `REDIS_FORCE_AOF`标志强制服务器将当前执行的命令写入到AOF文件里面，`REDIS_FORCE_REPL`标志强制主服务器将当前执行的命令复制给所有从服务器。执行`PUTSUB`命令会使客户端打开`REDIS_FORCE_AOF`标志, 执行`SCRIPT LOAD`命令会使客户端打开`REDIS_FORCE_AOF`标志和`REDIS_FORCE_REPL`标志.
- 在主服务器进行命令传播期间, 从服务器需要向主服务器发送`REPLICATION ACK`命令, 在发送这个命令之前, 从服务器必须打开主服务器对应的客户端的`REDIS_MASTER_FORCE_REPLY`标志, 否则发送操作会被拒绝执行。

### 输入缓冲区
客户端状态的输入缓冲区用于保存客户端发送的命令请求:
```c
typedef struct redisClient {
  sds querybuf;
}
```

- 输入缓冲区的大小会根据输入内容动态地缩小或者扩大, 但它的自大大小不能超过`1GB`, 否则服务器将关闭这个客户端, 否则服务器将关闭这个客户端

### 命令与命令参数
在服务器将客户端发送的命令请求保存到客户端状态的`querybuf`属性之后, 服务器将对命令请求的内容进行分析, 并将得出的命令参数以及命令参数的个数分别保存到客户端状态`argv`属性和`argc`属性。

```c
typedef struct redisClient {
  robj **argv;
  int argc;
}
```

- argv 属性是一个数组, 数组中的每个项都是一个字符串对象, 其中argv[0]是要执行命令, 而之后的其他项则是传给命令的参数
- argc: 属性则负责记录`argv`数组的额长度.

### 命令的实现函数
当服务器从协议内容中分析并得出`argv`属性和`argc`属性的值之后, 服务器将根据`argv[0]`的值, 该命令表中查找命令对应的命令实现函数。

每一个命令的名字和具体的命令存入的是一个字典, 字典的键就是具体的操作, 字典的值是命令所对应的`redisCommand`结构, 这个结构保存了命令的`实现函数`, `命令的标志`, 命令应该给定的参数个数, 命令的总执行次数, 和总消耗时长等统计信息。

- 针对命令表的查找操作不区分输入字母的大小写, 所以无论argv[0]是"SET", "set", "SeT"等等。

### 输出缓冲区
执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面, 每个客户端都有两个输出缓冲区可用, 一个缓冲区的大小是固定的, 另一个缓冲区的大小是可变的。

- 固定大小的缓冲区用于保存那些长度比较小的回复。
- 可变大小的缓冲区用户保存那些长度比较大的回复.

#### 固定大小缓冲区
固定大小缓冲区由`buf`和`bufpos`两个属性:
```c
typedef struct redisClient {
  char buf[REDIS_REPLY_CHUNK_BYTES];
  int bufpos;
}
```
- buf 是一个大小为`REDIS_REPLY_CHUNK_BYTES`字节的字节数组
- bufpos属性则记录了buf数组目前已经使用的字节数量
- `REDIS_REPLY_CHUNK_BYTES`常量目前的默认值是`16*1024`
- 当buf数组的空间已经用完, 或者回复因为太大而没有办法放进buf数组里面时, 服务器就会开始使用可变大小缓冲区。

#### 可变大小缓冲区
可变大小缓冲区由reply链表和一个或多个字符串对象组成:
```c
typedef struct redisClient {
  list *reply;
}
```

通过使用链表来链接多个字符串对象, 服务器可以为客户端保存一个非常长的命令回复, 而不必受到固定大小缓冲区16KB大小的限制.

### 身份验证
客户端状态`authenticated`属性用于记录客户端是否通过了身份验证:
```c
typedef struct redisClient {
  int authenticated;
}
```

- `authenticated = 0`， 表示客户端未通过身份验证
- `authenticated = 1`, 客户端已经通过了身份验证

当客户端`authenticated = 0`时, 除了`AUTH`命令之外, 客户端发送的所有其他命令都会被服务器拒绝执行.

> NOTE: `authenticated`属性仅在服务器启用了身份验证功能时使用. 如果服务器没有启用身份验证功能的话, 那么即使`authenticated = 0`, 服务器也不会拒绝执行客户端发送的命令请求。

### 时间
最后, 客户端还有几个和时间有关的属性:
```c
typedef struct redisClient {
  time_t ctime;
  time_t lastinteraction;
  time_t obuf_soft_limit_reached_time;
}
```

- ctime: 记录了创建客户端的时间, 这个时间可以用来计算客户端与服务器已经链接了多少秒。`CLIENT list`命令的`age`域记录了这个秒数:
- lastinteraction: 属性记录了客户端与服务器最后一次进行互动的时间, 这里的互动可以是客户端向服务器发送命令请求, 也可以是服务器向客户端发送命令回复.
  - lastinteraction属性可以用来计算客户端的空转(idle)时间, 距离客户端与服务器最后一次进行互动以来, 已经过去多少秒.`CLIENT list`命令的`idle`域记录了这个秒数.
- `obuf_soft_limit_reached_time`: 记录了输出缓冲区第一次到达软性限制的时间。

## 客户端的创建与关闭
### 创建普通客户端
如果客户端是通过网络与服务器进行连接的普通客户端, 那么客户端使用connect函数连接到服务器时, 服务器就会调用连接事件处理器,为客户端创建响应的客户端状态, 并将这个新的客户端状态添加到服务器状态结构`clients`链表的末尾.

### 关闭普通客户端
一个普通客户端可以因为多种原因而被关闭:
- 如果客户端进程退出或者被杀死, 那么客户端与服务器之间的网络连接将被关闭, 从而造成客户端被关闭
- 如果客户端服务器发送了带有不符合协议格式的命令请求, 那么客户端也会被服务器关闭
- 如果客户端成为了`CLIENT KILL`命令的目标, 那么它也会被关闭
- 如果用户为服务器设置了`timeout`配置选项, 那么当客户端的空转时间超过`timeout`选项的配置的值时, 客户端将被关闭.
  - 如果客户端是主服务器(打开了REDIS_MAASTER)标志, 从服务器(打开了REDIS_SLAVE)标志, 正被`BLPOP`等命令阻塞(打开了REDIS_BLOCKED)标志
, 或者正在执行`SUBSCRIBE`,`PSUBSCRIBE`等订阅命令，那么即使客户端的空转时间超过了`timeout`选项的值, 客户端也不会被服务器关闭
- 如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小(默认为`1GB`), 那么这个客户端会被服务器关闭
- 如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小, 那么这个客户端会被服务器关闭。

#### 缓冲区限制策略
为了避免客户端的回复过大, 占用过多的服务器资源, 服务器会`时刻检查客户端的输出缓冲区大小`。并在缓冲区的大小超出范围时, 执行响应的限制操作。

- 硬性限制: 如果输出缓冲区的大小超过了硬性限制所设置的大小, 那么服务器就立刻关闭
- 软性限制: 如果输出缓冲区的大小超过了软性限制所设置的大小, 但没有超过硬性限制. 那么服务器将使用客户端状态结构的`obuf_soft_limit_reached_time`属性记录下客户端到达软性限制的起始时间；
  - 之后服务器会继续监视客户端, 如果输出缓冲区的大小一直超出软性限制, 并且持续时间超过服务器设定的时长, 那么服务器就关闭客户端
  - 如果输出缓冲区的大小在指定时间之内, 不再超出软性限制, 那么客户端不会被关闭， 并且`obuf_soft_limit_reached_time`属性的值也会被清零

#### 配置服务器软性限制和硬性限制
使用`client-output-buffer-limit`选项可以为普通客户端, 从服务器客户端, 执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制.

```cnf
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
```
- 第一行设置将普通客户端的硬性限制和软性限制都设置为0, 表示不限制客户端的输出缓冲区。

## Lua脚本的伪客户端
服务器会在初始化时创建负责执行`Lua`脚本中包含的Redis命令的伪客户端, 并将这个伪客户端关联在服务器状态结构的`lua_client`属性中:
```c
struct redisServer {
  redisClient *lua_client;
}
```

lua_client伪客户端在服务器运行的整个生命周期中会一直存在, 只有服务器被关闭时, 这个客户端才会被关闭.

## AOF文件的伪客户端
服务器在载入AOF文件时, 会创建用于执行AOF文件包含的Redis命令的伪客户端, 并在载入完成之后, 关闭这个伪客户端.
